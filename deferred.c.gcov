        -:    0:Source:src/memory/deferred.c
        -:    1:#include "deferred.h"
        -:    2:#include <stdio.h>
        -:    3:
        -:    4:// -- Context Management --
        -:    5:
    #####:    6:DeferredContext* mk_deferred_context(int batch_size) {
    #####:    7:    DeferredContext* ctx = malloc(sizeof(DeferredContext));
    #####:    8:    if (!ctx) return NULL;
    #####:    9:    ctx->obj_lookup = hashmap_new();
    #####:   10:    if (!ctx->obj_lookup) {
    #####:   11:        free(ctx);
    #####:   12:        return NULL;
        -:   13:    }
    #####:   14:    ctx->pending = NULL;
    #####:   15:    ctx->pending_count = 0;
    #####:   16:    ctx->batch_size = batch_size > 0 ? batch_size : 32;
    #####:   17:    ctx->total_deferred = 0;
    #####:   18:    return ctx;
        -:   19:}
        -:   20:
    #####:   21:void free_deferred_context(DeferredContext* ctx) {
    #####:   22:    if (!ctx) return;
    #####:   23:    DeferredDec* d = ctx->pending;
    #####:   24:    while (d) {
    #####:   25:        DeferredDec* next = d->next;
    #####:   26:        free(d);
    #####:   27:        d = next;
        -:   28:    }
    #####:   29:    if (ctx->obj_lookup) {
    #####:   30:        hashmap_free(ctx->obj_lookup);
        -:   31:    }
    #####:   32:    free(ctx);
        -:   33:}
        -:   34:
        -:   35:// -- Deferred Operations --
        -:   36:
    #####:   37:void defer_decrement(DeferredContext* ctx, void* obj) {
    #####:   38:    if (!ctx || !obj) return;
        -:   39:
        -:   40:    // O(1) lookup using hash map
    #####:   41:    DeferredDec* d = (DeferredDec*)hashmap_get(ctx->obj_lookup, obj);
    #####:   42:    if (d) {
    #####:   43:        d->count++;
    #####:   44:        return;
        -:   45:    }
        -:   46:
        -:   47:    // Add new entry
    #####:   48:    d = malloc(sizeof(DeferredDec));
    #####:   49:    if (!d) return;  // Allocation failed
    #####:   50:    d->obj = obj;
    #####:   51:    d->count = 1;
    #####:   52:    d->next = ctx->pending;
    #####:   53:    ctx->pending = d;
    #####:   54:    ctx->pending_count++;
    #####:   55:    ctx->total_deferred++;
        -:   56:
        -:   57:    // Add to hash map for O(1) lookup
    #####:   58:    hashmap_put(ctx->obj_lookup, obj, d);
        -:   59:}
        -:   60:
    #####:   61:void process_deferred(DeferredContext* ctx, int max_count) {
    #####:   62:    if (!ctx || !ctx->pending) return;
        -:   63:
    #####:   64:    int processed = 0;
    #####:   65:    DeferredDec** prev = &ctx->pending;
        -:   66:
    #####:   67:    while (*prev && processed < max_count) {
    #####:   68:        DeferredDec* d = *prev;
        -:   69:
        -:   70:        // Process one decrement for this object
    #####:   71:        d->count--;
    #####:   72:        processed++;
        -:   73:
    #####:   74:        if (d->count <= 0) {
        -:   75:            // Remove from hash map
    #####:   76:            hashmap_remove(ctx->obj_lookup, d->obj);
        -:   77:            // Remove from list
    #####:   78:            *prev = d->next;
    #####:   79:            ctx->pending_count--;
        -:   80:            // Note: Actual freeing of d->obj handled by caller
        -:   81:            // This is just bookkeeping
    #####:   82:            free(d);
        -:   83:        } else {
    #####:   84:            prev = &d->next;
        -:   85:        }
        -:   86:    }
        -:   87:}
        -:   88:
    #####:   89:void flush_deferred(DeferredContext* ctx) {
    #####:   90:    while (ctx && ctx->pending) {
    #####:   91:        process_deferred(ctx, ctx->batch_size);
        -:   92:    }
    #####:   93:}
        -:   94:
    #####:   95:int should_process_deferred(DeferredContext* ctx) {
    #####:   96:    if (!ctx) return 0;
    #####:   97:    return ctx->pending_count >= ctx->batch_size;
        -:   98:}
        -:   99:
        -:  100:// -- Code Generation --
        -:  101:
      280:  102:void gen_deferred_runtime(void) {
      280:  103:    printf("\n// Phase 7: Deferred RC Fallback Runtime\n");
      280:  104:    printf("// For mutable cycles that never freeze\n");
      280:  105:    printf("// Bounded O(k) processing at safe points\n\n");
        -:  106:
      280:  107:    printf("typedef struct DeferredDec {\n");
      280:  108:    printf("    Obj* obj;\n");
      280:  109:    printf("    int count;\n");
      280:  110:    printf("    struct DeferredDec* next;      // For linked list\n");
      280:  111:    printf("    struct DeferredDec* hash_next; // For hash bucket chain\n");
      280:  112:    printf("} DeferredDec;\n\n");
        -:  113:
      280:  114:    printf("#define DEFERRED_HASH_SIZE 256\n");
      280:  115:    printf("DeferredDec* DEFERRED_HASH[DEFERRED_HASH_SIZE];\n");
      280:  116:    printf("DeferredDec* DEFERRED_HEAD = NULL;\n");
      280:  117:    printf("int DEFERRED_COUNT = 0;\n");
      280:  118:    printf("#define DEFERRED_BATCH_SIZE 32\n\n");
        -:  119:
      280:  120:    printf("static size_t deferred_hash_ptr(void* p) {\n");
      280:  121:    printf("    size_t x = (size_t)p;\n");
      280:  122:    printf("    x = ((x >> 16) ^ x) * 0x45d9f3b;\n");
      280:  123:    printf("    x = ((x >> 16) ^ x) * 0x45d9f3b;\n");
      280:  124:    printf("    return (x >> 16) ^ x;\n");
      280:  125:    printf("}\n\n");
        -:  126:
      280:  127:    printf("void defer_dec(Obj* obj) {\n");
      280:  128:    printf("    if (!obj) return;\n");
      280:  129:    printf("    size_t idx = deferred_hash_ptr(obj) %% DEFERRED_HASH_SIZE;\n");
      280:  130:    printf("    DeferredDec* d = DEFERRED_HASH[idx];\n");
      280:  131:    printf("    while (d) {\n");
      280:  132:    printf("        if (d->obj == obj) { d->count++; return; }\n");
      280:  133:    printf("        d = d->hash_next;\n");
      280:  134:    printf("    }\n");
      280:  135:    printf("    d = malloc(sizeof(DeferredDec));\n");
      280:  136:    printf("    if (!d) return;\n");
      280:  137:    printf("    d->obj = obj;\n");
      280:  138:    printf("    d->count = 1;\n");
      280:  139:    printf("    d->next = DEFERRED_HEAD;\n");
      280:  140:    printf("    d->hash_next = DEFERRED_HASH[idx];\n");
      280:  141:    printf("    DEFERRED_HEAD = d;\n");
      280:  142:    printf("    DEFERRED_HASH[idx] = d;\n");
      280:  143:    printf("    DEFERRED_COUNT++;\n");
      280:  144:    printf("}\n\n");
        -:  145:
      280:  146:    printf("static void deferred_remove_from_hash(DeferredDec* d) {\n");
      280:  147:    printf("    size_t idx = deferred_hash_ptr(d->obj) %% DEFERRED_HASH_SIZE;\n");
      280:  148:    printf("    DeferredDec** hp = &DEFERRED_HASH[idx];\n");
      280:  149:    printf("    while (*hp) {\n");
      280:  150:    printf("        if (*hp == d) { *hp = d->hash_next; return; }\n");
      280:  151:    printf("        hp = &(*hp)->hash_next;\n");
      280:  152:    printf("    }\n");
      280:  153:    printf("}\n\n");
        -:  154:
      280:  155:    printf("void process_deferred_batch(int max_count) {\n");
      280:  156:    printf("    int processed = 0;\n");
      280:  157:    printf("    DeferredDec** prev = &DEFERRED_HEAD;\n");
      280:  158:    printf("    while (*prev && processed < max_count) {\n");
      280:  159:    printf("        DeferredDec* d = *prev;\n");
      280:  160:    printf("        d->count--;\n");
      280:  161:    printf("        processed++;\n");
      280:  162:    printf("        if (d->count <= 0) {\n");
      280:  163:    printf("            *prev = d->next;\n");
      280:  164:    printf("            deferred_remove_from_hash(d);\n");
      280:  165:    printf("            DEFERRED_COUNT--;\n");
      280:  166:    printf("            // Apply actual decrement\n");
      280:  167:    printf("            d->obj->mark--;\n");
      280:  168:    printf("            if (d->obj->mark <= 0) {\n");
      280:  169:    printf("                // Object is dead, defer children\n");
      280:  170:    printf("                if (d->obj->is_pair) {\n");
      280:  171:    printf("                    if (d->obj->a) defer_dec(d->obj->a);\n");
      280:  172:    printf("                    if (d->obj->b) defer_dec(d->obj->b);\n");
      280:  173:    printf("                }\n");
      280:  174:    printf("                invalidate_weak_refs_for(d->obj);\n");
      280:  175:    printf("                free(d->obj);\n");
      280:  176:    printf("            }\n");
      280:  177:    printf("            free(d);\n");
      280:  178:    printf("        } else {\n");
      280:  179:    printf("            prev = &d->next;\n");
      280:  180:    printf("        }\n");
      280:  181:    printf("    }\n");
      280:  182:    printf("}\n\n");
        -:  183:
      280:  184:    printf("// Safe point: process deferred if threshold reached\n");
      280:  185:    printf("void safe_point() {\n");
      280:  186:    printf("    if (DEFERRED_COUNT >= DEFERRED_BATCH_SIZE) {\n");
      280:  187:    printf("        process_deferred_batch(DEFERRED_BATCH_SIZE);\n");
      280:  188:    printf("    }\n");
      280:  189:    printf("}\n\n");
        -:  190:
      280:  191:    printf("// Flush all deferred at program end\n");
      280:  192:    printf("void flush_all_deferred() {\n");
      280:  193:    printf("    while (DEFERRED_HEAD) {\n");
      280:  194:    printf("        process_deferred_batch(DEFERRED_BATCH_SIZE);\n");
      280:  195:    printf("    }\n");
      280:  196:    printf("}\n\n");
        -:  197:
      280:  198:    printf("// Deferred release for cyclic structures\n");
      280:  199:    printf("void deferred_release(Obj* obj) {\n");
      280:  200:    printf("    if (!obj) return;\n");
      280:  201:    printf("    // For cyclic structures, use deferred decrement\n");
      280:  202:    printf("    defer_dec(obj);\n");
      280:  203:    printf("    // Process if threshold reached\n");
      280:  204:    printf("    safe_point();\n");
      280:  205:    printf("}\n\n");
      280:  206:}
        -:  207:
    #####:  208:void gen_safe_point(const char* location) {
    #####:  209:    printf("    safe_point(); // %s\n", location ? location : "safe point");
    #####:  210:}
