        -:    0:Source:src/analysis/escape.c
        -:    1:#include "escape.h"
        -:    2:#include <string.h>
        -:    3:
        -:    4:// Global analysis context
        -:    5:AnalysisContext* g_analysis_ctx = NULL;
        -:    6:
        -:    7:// -- Context Management --
        -:    8:
        5:    9:AnalysisContext* mk_analysis_ctx(void) {
        5:   10:    AnalysisContext* ctx = malloc(sizeof(AnalysisContext));
       5*:   11:    if (!ctx) return NULL;
        5:   12:    ctx->vars = NULL;
        5:   13:    ctx->current_depth = 0;
        5:   14:    ctx->in_lambda = 0;
        5:   15:    return ctx;
        -:   16:}
        -:   17:
    #####:   18:void free_analysis_ctx(AnalysisContext* ctx) {
    #####:   19:    if (!ctx) return;
    #####:   20:    VarUsage* v = ctx->vars;
    #####:   21:    while (v) {
    #####:   22:        VarUsage* next = v->next;
    #####:   23:        free(v->name);
    #####:   24:        free(v);
    #####:   25:        v = next;
        -:   26:    }
    #####:   27:    free(ctx);
        -:   28:}
        -:   29:
       28:   30:VarUsage* find_var(AnalysisContext* ctx, const char* name) {
      28*:   31:    if (!ctx) return NULL;
       28:   32:    VarUsage* v = ctx->vars;
       38:   33:    while (v) {
       32:   34:        if (strcmp(v->name, name) == 0) return v;
       10:   35:        v = v->next;
        -:   36:    }
        6:   37:    return NULL;
        -:   38:}
        -:   39:
        6:   40:void add_var(AnalysisContext* ctx, const char* name) {
       6*:   41:    if (!ctx || !name) return;
        6:   42:    VarUsage* v = malloc(sizeof(VarUsage));
       6*:   43:    if (!v) return;
        6:   44:    v->name = strdup(name);
        6:   45:    if (!v->name) {
    #####:   46:        free(v);
    #####:   47:        return;
        -:   48:    }
        6:   49:    v->use_count = 0;
        6:   50:    v->last_use_depth = -1;
        6:   51:    v->escape_class = ESCAPE_NONE;
        6:   52:    v->captured_by_lambda = 0;
        6:   53:    v->freed = 0;
        6:   54:    v->next = ctx->vars;
        6:   55:    ctx->vars = v;
        -:   56:}
        -:   57:
       13:   58:void record_use(AnalysisContext* ctx, const char* name) {
      13*:   59:    if (!ctx) return;
       13:   60:    VarUsage* v = find_var(ctx, name);
       13:   61:    if (v) {
        8:   62:        v->use_count++;
        8:   63:        v->last_use_depth = ctx->current_depth;
        8:   64:        if (ctx->in_lambda) {
        1:   65:            v->captured_by_lambda = 1;
        -:   66:        }
        -:   67:    }
        -:   68:}
        -:   69:
        -:   70:// -- Analysis Functions --
        -:   71:
        4:   72:static void analyze_list(Value* list, AnalysisContext* ctx) {
       12:   73:    while (!is_nil(list)) {
        8:   74:        analyze_expr(car(list), ctx);
        8:   75:        list = cdr(list);
        -:   76:    }
        4:   77:}
        -:   78:
       18:   79:void analyze_expr(Value* expr, AnalysisContext* ctx) {
      18*:   80:    if (!expr || !ctx || is_nil(expr)) return;
        -:   81:
       18:   82:    ctx->current_depth++;
        -:   83:
       18:   84:    switch (expr->tag) {
       13:   85:        case T_SYM:
       13:   86:            record_use(ctx, expr->s);
       13:   87:            break;
        -:   88:
        5:   89:        case T_CELL: {
        5:   90:            Value* op = car(expr);
        5:   91:            Value* args = cdr(expr);
        -:   92:
        5:   93:            if (op->tag == T_SYM) {
        5:   94:                if (strcmp(op->s, "quote") == 0) {
        -:   95:                    // Don't analyze quoted expressions
        5:   96:                } else if (strcmp(op->s, "lambda") == 0) {
        1:   97:                    int saved_in_lambda = ctx->in_lambda;
        1:   98:                    ctx->in_lambda = 1;
        1:   99:                    if (!is_nil(args) && !is_nil(cdr(args))) {
        1:  100:                        analyze_expr(car(cdr(args)), ctx);
        -:  101:                    }
        1:  102:                    ctx->in_lambda = saved_in_lambda;
        4:  103:                } else if (strcmp(op->s, "let") == 0) {
    #####:  104:                    Value* bindings = car(args);
    #####:  105:                    Value* body = car(cdr(args));
    #####:  106:                    while (!is_nil(bindings)) {
    #####:  107:                        Value* bind = car(bindings);
    #####:  108:                        if (!is_nil(bind) && !is_nil(cdr(bind))) {
    #####:  109:                            analyze_expr(car(cdr(bind)), ctx);
        -:  110:                        }
    #####:  111:                        bindings = cdr(bindings);
        -:  112:                    }
    #####:  113:                    analyze_expr(body, ctx);
        4:  114:                } else if (strcmp(op->s, "if") == 0) {
    #####:  115:                    analyze_list(args, ctx);
        -:  116:                } else {
        4:  117:                    analyze_expr(op, ctx);
        4:  118:                    analyze_list(args, ctx);
        -:  119:                }
        -:  120:            } else {
    #####:  121:                analyze_expr(op, ctx);
    #####:  122:                analyze_list(args, ctx);
        -:  123:            }
        5:  124:            break;
        -:  125:        }
    #####:  126:        default:
    #####:  127:            break;
        -:  128:    }
        -:  129:
       18:  130:    ctx->current_depth--;
        -:  131:}
        -:  132:
       14:  133:void analyze_escape(Value* expr, AnalysisContext* ctx, EscapeClass context) {
      14*:  134:    if (!expr || !ctx || is_nil(expr)) return;
        -:  135:
       14:  136:    switch (expr->tag) {
        9:  137:        case T_SYM: {
        9:  138:            VarUsage* v = find_var(ctx, expr->s);
        9:  139:            if (v && context > v->escape_class) {
        6:  140:                v->escape_class = context;
        -:  141:            }
        9:  142:            break;
        -:  143:        }
        5:  144:        case T_CELL: {
        5:  145:            Value* op = car(expr);
        5:  146:            Value* args = cdr(expr);
        -:  147:
        5:  148:            if (op->tag == T_SYM) {
        5:  149:                if (strcmp(op->s, "lambda") == 0) {
        1:  150:                    int saved = ctx->in_lambda;
        1:  151:                    ctx->in_lambda = 1;
        1:  152:                    if (!is_nil(args) && !is_nil(cdr(args))) {
        1:  153:                        analyze_escape(car(cdr(args)), ctx, ESCAPE_GLOBAL);
        -:  154:                    }
        1:  155:                    ctx->in_lambda = saved;
        4:  156:                } else if (strcmp(op->s, "let") == 0) {
    #####:  157:                    Value* bindings = car(args);
    #####:  158:                    Value* body = car(cdr(args));
    #####:  159:                    while (!is_nil(bindings)) {
    #####:  160:                        Value* bind = car(bindings);
    #####:  161:                        if (!is_nil(bind) && !is_nil(cdr(bind))) {
    #####:  162:                            analyze_escape(car(cdr(bind)), ctx, ESCAPE_NONE);
        -:  163:                        }
    #####:  164:                        bindings = cdr(bindings);
        -:  165:                    }
    #####:  166:                    analyze_escape(body, ctx, context);
        4:  167:                } else if (strcmp(op->s, "letrec") == 0) {
        -:  168:                    // letrec: bindings can reference each other, potential cycles
    #####:  169:                    Value* bindings = car(args);
    #####:  170:                    Value* body = car(cdr(args));
        -:  171:                    // First pass: mark all bound vars as potentially escaping
    #####:  172:                    Value* b = bindings;
    #####:  173:                    while (!is_nil(b)) {
    #####:  174:                        Value* bind = car(b);
    #####:  175:                        if (!is_nil(bind)) {
    #####:  176:                            Value* sym = car(bind);
    #####:  177:                            if (sym && sym->tag == T_SYM) {
    #####:  178:                                VarUsage* v = find_var(ctx, sym->s);
    #####:  179:                                if (v) v->escape_class = ESCAPE_GLOBAL;
        -:  180:                            }
        -:  181:                        }
    #####:  182:                        b = cdr(b);
        -:  183:                    }
        -:  184:                    // Analyze binding expressions
    #####:  185:                    while (!is_nil(bindings)) {
    #####:  186:                        Value* bind = car(bindings);
    #####:  187:                        if (!is_nil(bind) && !is_nil(cdr(bind))) {
    #####:  188:                            analyze_escape(car(cdr(bind)), ctx, ESCAPE_GLOBAL);
        -:  189:                        }
    #####:  190:                        bindings = cdr(bindings);
        -:  191:                    }
    #####:  192:                    analyze_escape(body, ctx, context);
        4:  193:                } else if (strcmp(op->s, "set!") == 0) {
        -:  194:                    // set! mutates variable - mark as escaping
    #####:  195:                    Value* target = car(args);
    #####:  196:                    if (target && target->tag == T_SYM) {
    #####:  197:                        VarUsage* v = find_var(ctx, target->s);
    #####:  198:                        if (v) v->escape_class = ESCAPE_GLOBAL;
        -:  199:                    }
        -:  200:                    // Analyze the value being assigned
    #####:  201:                    if (!is_nil(cdr(args))) {
    #####:  202:                        analyze_escape(car(cdr(args)), ctx, ESCAPE_GLOBAL);
        -:  203:                    }
        4:  204:                } else if (strcmp(op->s, "cons") == 0) {
    #####:  205:                    while (!is_nil(args)) {
    #####:  206:                        analyze_escape(car(args), ctx, ESCAPE_ARG);
    #####:  207:                        args = cdr(args);
        -:  208:                    }
        -:  209:                } else {
       12:  210:                    while (!is_nil(args)) {
        8:  211:                        analyze_escape(car(args), ctx, ESCAPE_ARG);
        8:  212:                        args = cdr(args);
        -:  213:                    }
        -:  214:                }
        -:  215:            } else {
        -:  216:                // Non-symbol operator (higher-order) - analyze it too
    #####:  217:                analyze_escape(op, ctx, ESCAPE_ARG);
    #####:  218:                while (!is_nil(args)) {
    #####:  219:                    analyze_escape(car(args), ctx, ESCAPE_ARG);
    #####:  220:                    args = cdr(args);
        -:  221:                }
        -:  222:            }
        5:  223:            break;
        -:  224:        }
    #####:  225:        default:
    #####:  226:            break;
        -:  227:    }
        -:  228:}
        -:  229:
        -:  230:// -- Capture Tracking --
        -:  231:
        -:  232:// Helper to check if variable is in bound list
    #####:  233:static int is_bound(Value* bound, Value* sym) {
    #####:  234:    while (!is_nil(bound)) {
    #####:  235:        Value* pair = car(bound);
    #####:  236:        if (pair->tag == T_CELL) {
    #####:  237:            Value* key = car(pair);
    #####:  238:            if (key->tag == T_SYM && sym->tag == T_SYM &&
    #####:  239:                strcmp(key->s, sym->s) == 0) {
    #####:  240:                return 1;
        -:  241:            }
        -:  242:        }
    #####:  243:        bound = cdr(bound);
        -:  244:    }
    #####:  245:    return 0;
        -:  246:}
        -:  247:
        -:  248:// Helper to extend bound list
    #####:  249:static Value* extend_bound(Value* bound, Value* sym) {
    #####:  250:    return mk_cell(mk_cell(sym, mk_int(1)), bound);
        -:  251:}
        -:  252:
    #####:  253:void find_free_vars(Value* expr, Value* bound, char*** free_vars, int* count) {
    #####:  254:    if (!expr || is_nil(expr)) return;
        -:  255:
    #####:  256:    if (expr->tag == T_SYM) {
    #####:  257:        if (!is_bound(bound, expr)) {
        -:  258:            // Add to free vars if not already present
    #####:  259:            for (int i = 0; i < *count; i++) {
    #####:  260:                if (strcmp((*free_vars)[i], expr->s) == 0) return;
        -:  261:            }
    #####:  262:            char** new_vars = realloc(*free_vars, (*count + 1) * sizeof(char*));
    #####:  263:            if (!new_vars) return;  // Keep existing on failure
    #####:  264:            *free_vars = new_vars;
    #####:  265:            char* dup = strdup(expr->s);
    #####:  266:            if (!dup) return;
    #####:  267:            (*free_vars)[*count] = dup;
    #####:  268:            (*count)++;
        -:  269:        }
    #####:  270:        return;
        -:  271:    }
        -:  272:
    #####:  273:    if (expr->tag == T_CELL) {
    #####:  274:        Value* op = car(expr);
    #####:  275:        Value* args = cdr(expr);
        -:  276:
    #####:  277:        if (op->tag == T_SYM) {
    #####:  278:            if (strcmp(op->s, "quote") == 0) {
    #####:  279:                return;
        -:  280:            }
    #####:  281:            if (strcmp(op->s, "lambda") == 0) {
    #####:  282:                Value* params = car(args);
    #####:  283:                Value* body = car(cdr(args));
    #####:  284:                Value* new_bound = bound;
    #####:  285:                while (!is_nil(params)) {
    #####:  286:                    new_bound = extend_bound(new_bound, car(params));
    #####:  287:                    params = cdr(params);
        -:  288:                }
    #####:  289:                find_free_vars(body, new_bound, free_vars, count);
    #####:  290:                return;
        -:  291:            }
    #####:  292:            if (strcmp(op->s, "let") == 0) {
    #####:  293:                Value* bindings = car(args);
    #####:  294:                Value* body = car(cdr(args));
    #####:  295:                Value* new_bound = bound;
        -:  296:
    #####:  297:                while (!is_nil(bindings)) {
    #####:  298:                    Value* bind = car(bindings);
    #####:  299:                    Value* sym = car(bind);
    #####:  300:                    Value* val_expr = car(cdr(bind));
        -:  301:
    #####:  302:                    find_free_vars(val_expr, bound, free_vars, count);
    #####:  303:                    new_bound = extend_bound(new_bound, sym);
    #####:  304:                    bindings = cdr(bindings);
        -:  305:                }
        -:  306:
    #####:  307:                find_free_vars(body, new_bound, free_vars, count);
    #####:  308:                return;
        -:  309:            }
        -:  310:        }
        -:  311:
        -:  312:        // Recurse on all subexpressions
    #####:  313:        find_free_vars(op, bound, free_vars, count);
    #####:  314:        while (!is_nil(args)) {
    #####:  315:            find_free_vars(car(args), bound, free_vars, count);
    #####:  316:            args = cdr(args);
        -:  317:        }
        -:  318:    }
        -:  319:}
