        -:    0:Source:src/eval/eval.c
        -:    1:#include "eval.h"
        -:    2:#include "../codegen/codegen.h"
        -:    3:#include "../analysis/escape.h"
        -:    4:#include "../analysis/shape.h"
        -:    5:#include "../util/dstring.h"
        -:    6:#include <stdio.h>
        -:    7:#include <string.h>
        -:    8:
        -:    9:// -- Symbol Table --
        -:   10:
        -:   11:Value* NIL = NULL;
        -:   12:Value* SYM_T = NULL;
        -:   13:Value* SYM_QUOTE = NULL;
        -:   14:Value* SYM_IF = NULL;
        -:   15:Value* SYM_LAMBDA = NULL;
        -:   16:Value* SYM_LET = NULL;
        -:   17:Value* SYM_LETREC = NULL;
        -:   18:Value* SYM_AND = NULL;
        -:   19:Value* SYM_OR = NULL;
        -:   20:Value* SYM_LIFT = NULL;
        -:   21:Value* SYM_RUN = NULL;
        -:   22:Value* SYM_EM = NULL;
        -:   23:Value* SYM_SCAN = NULL;
        -:   24:Value* SYM_GET_META = NULL;
        -:   25:Value* SYM_SET_META = NULL;
        -:   26:
       98:   27:void init_syms(void) {
       98:   28:    NIL = alloc_val(T_NIL);
       98:   29:    SYM_T = mk_sym("t");
       98:   30:    SYM_QUOTE = mk_sym("quote");
       98:   31:    SYM_IF = mk_sym("if");
       98:   32:    SYM_LAMBDA = mk_sym("lambda");
       98:   33:    SYM_LET = mk_sym("let");
       98:   34:    SYM_LETREC = mk_sym("letrec");
       98:   35:    SYM_AND = mk_sym("and");
       98:   36:    SYM_OR = mk_sym("or");
       98:   37:    SYM_LIFT = mk_sym("lift");
       98:   38:    SYM_RUN = mk_sym("run");
       98:   39:    SYM_EM = mk_sym("EM");
       98:   40:    SYM_SCAN = mk_sym("scan");
       98:   41:    SYM_GET_META = mk_sym("get-meta");
       98:   42:    SYM_SET_META = mk_sym("set-meta!");
       98:   43:}
        -:   44:
        -:   45:// -- Environment --
        -:   46:
       79:   47:Value* env_lookup(Value* env, Value* sym) {
      739:   48:    while (!is_nil(env)) {
      739:   49:        Value* pair = car(env);
      739:   50:        if (sym_eq(car(pair), sym)) return cdr(pair);
      660:   51:        env = cdr(env);
        -:   52:    }
    #####:   53:    return NULL;
        -:   54:}
        -:   55:
     1975:   56:Value* env_extend(Value* env, Value* sym, Value* val) {
     1975:   57:    return mk_cell(mk_cell(sym, val), env);
        -:   58:}
        -:   59:
        -:   60:// -- MEnv --
        -:   61:
    #####:   62:Value* menv_env(Value* menv) {
    #####:   63:    return menv->menv.env;
        -:   64:}
        -:   65:
    #####:   66:Value* menv_parent(Value* menv) {
    #####:   67:    return menv->menv.parent;
        -:   68:}
        -:   69:
      111:   70:Value* mk_menv(Value* parent, Value* env) {
      111:   71:    Value* v = alloc_val(T_MENV);
      111:   72:    v->menv.env = env;
      111:   73:    v->menv.parent = parent;
      111:   74:    v->menv.h_app = h_app_default;
      111:   75:    v->menv.h_let = h_let_default;
      111:   76:    v->menv.h_if = h_if_default;
      111:   77:    v->menv.h_lit = h_lit_default;
      111:   78:    v->menv.h_var = h_var_default;
      111:   79:    return v;
        -:   80:}
        -:   81:
        -:   82:// -- Default Handlers --
        -:   83:
      122:   84:Value* h_lit_default(Value* exp, Value* menv) {
      122:   85:    return exp;
        -:   86:}
        -:   87:
       79:   88:Value* h_var_default(Value* exp, Value* menv) {
       79:   89:    Value* v = env_lookup(menv->menv.env, exp);
       79:   90:    if (!v) {
    #####:   91:        printf("Error: Unbound %s\n", exp->s);
    #####:   92:        return NIL;
        -:   93:    }
       79:   94:    return v;
        -:   95:}
        -:   96:
      126:   97:Value* eval_list(Value* list, Value* menv) {
      126:   98:    if (is_nil(list)) return NIL;
       80:   99:    Value* h = eval(car(list), menv);
       80:  100:    Value* t = eval_list(cdr(list), menv);
       80:  101:    return mk_cell(h, t);
        -:  102:}
        -:  103:
       46:  104:Value* h_app_default(Value* exp, Value* menv) {
       46:  105:    Value* f_expr = car(exp);
       46:  106:    Value* args_expr = cdr(exp);
        -:  107:
       46:  108:    Value* fn = eval(f_expr, menv);
      46*:  109:    if (!fn) return NIL;  // Guard: fn could be NULL
       46:  110:    Value* args = eval_list(args_expr, menv);
        -:  111:
       46:  112:    if (fn->tag == T_PRIM) return fn->prim(args, menv);
        -:  113:
        6:  114:    if (fn->tag == T_LAMBDA) {
        6:  115:        Value* params = fn->lam.params;
        6:  116:        Value* body = fn->lam.body;
        6:  117:        Value* closure_env = fn->lam.env;
        -:  118:
        6:  119:        Value* new_env = closure_env;
        6:  120:        Value* p = params;
        6:  121:        Value* a = args;
       12:  122:        while (!is_nil(p) && !is_nil(a)) {
        6:  123:            new_env = env_extend(new_env, car(p), car(a));
        6:  124:            p = cdr(p);
        6:  125:            a = cdr(a);
        -:  126:        }
        -:  127:
        6:  128:        Value* body_menv = mk_menv(menv->menv.parent, new_env);
        6:  129:        body_menv->menv.h_app = menv->menv.h_app;
        6:  130:        body_menv->menv.h_let = menv->menv.h_let;
        6:  131:        body_menv->menv.h_if = menv->menv.h_if;
        -:  132:
        6:  133:        return eval(body, body_menv);
        -:  134:    }
        -:  135:
    #####:  136:    printf("Error: Not a function: %s\n", val_to_str(fn));
    #####:  137:    return NIL;
        -:  138:}
        -:  139:
        -:  140:// Binding info for multi-let
        -:  141:typedef struct BindingInfo {
        -:  142:    Value* sym;
        -:  143:    Value* val;
        -:  144:    struct BindingInfo* next;
        -:  145:} BindingInfo;
        -:  146:
        6:  147:Value* h_let_default(Value* exp, Value* menv) {
        6:  148:    Value* args = cdr(exp);
        6:  149:    Value* bindings = car(args);
        6:  150:    Value* body = car(cdr(args));
        -:  151:
        6:  152:    int any_code = 0;
        6:  153:    Value* check_bindings = bindings;
        6:  154:    Value* new_env = menv->menv.env;
        -:  155:
        6:  156:    BindingInfo* bind_list = NULL;
        6:  157:    BindingInfo* bind_tail = NULL;
        -:  158:
       14:  159:    while (!is_nil(check_bindings)) {
        8:  160:        Value* bind = car(check_bindings);
        8:  161:        Value* sym = car(bind);
        8:  162:        Value* val_expr = car(cdr(bind));
        8:  163:        Value* val = eval(val_expr, menv);
        -:  164:
        8:  165:        if (val->tag == T_CODE) any_code = 1;
        -:  166:
        8:  167:        BindingInfo* info = malloc(sizeof(BindingInfo));
       8*:  168:        if (!info) continue;  // Skip on allocation failure
        8:  169:        info->sym = sym;
        8:  170:        info->val = val;
        8:  171:        info->next = NULL;
        -:  172:
        8:  173:        if (bind_tail) {
        2:  174:            bind_tail->next = info;
        2:  175:            bind_tail = info;
        -:  176:        } else {
        6:  177:            bind_list = bind_tail = info;
        -:  178:        }
        -:  179:
        8:  180:        check_bindings = cdr(check_bindings);
        -:  181:    }
        -:  182:
        6:  183:    if (any_code) {
        5:  184:        AnalysisContext* ctx = mk_analysis_ctx();
        5:  185:        ShapeContext* shape_ctx = mk_shape_context();
        -:  186:
        5:  187:        BindingInfo* b = bind_list;
       11:  188:        while (b) {
        6:  189:            add_var(ctx, b->sym->s);
        6:  190:            b = b->next;
        -:  191:        }
        -:  192:
        5:  193:        analyze_expr(body, ctx);
        5:  194:        analyze_escape(body, ctx, ESCAPE_GLOBAL);
        5:  195:        analyze_shapes_expr(exp, shape_ctx);
        -:  196:
        5:  197:        DString* all_decls = ds_new();
        5:  198:        DString* all_frees = ds_new();
        5:  199:        b = bind_list;
       11:  200:        while (b) {
        6:  201:            VarUsage* usage = find_var(ctx, b->sym->s);
       6*:  202:            int is_captured = usage ? usage->captured_by_lambda : 0;
       6*:  203:            int use_count = usage ? usage->use_count : 0;
       6*:  204:            int escape_class = usage ? usage->escape_class : ESCAPE_NONE;
        -:  205:
        6:  206:            ShapeInfo* shape_info = find_shape(shape_ctx, b->sym->s);
       6*:  207:            Shape var_shape = shape_info ? shape_info->shape : SHAPE_UNKNOWN;
        -:  208:
       6*:  209:            char* val_str = (b->val->tag == T_CODE) ? b->val->s : val_to_str(b->val);
        -:  210:
        6:  211:            if (b->val->tag != T_CODE) {
    #####:  212:                if (b->val->tag == T_INT) {
    #####:  213:                    ds_printf(all_decls, "  Obj* %s = mk_int(%ld);\n", b->sym->s, b->val->i);
        -:  214:                } else {
    #####:  215:                    ds_printf(all_decls, "  Obj* %s = %s;\n", b->sym->s, val_str);
        -:  216:                }
        -:  217:            } else {
        6:  218:                ds_printf(all_decls, "  Obj* %s = %s;\n", b->sym->s, val_str);
        -:  219:            }
        -:  220:
        6:  221:            const char* free_fn = shape_free_strategy(var_shape);
        -:  222:
        6:  223:            if (is_captured) {
        1:  224:                ds_printf(all_frees, "  // %s captured by closure - no free\n", b->sym->s);
        5:  225:            } else if (use_count == 0) {
    #####:  226:                ds_printf(all_decls, "  %s(%s); // unused\n", free_fn, b->sym->s);
        5:  227:            } else if (escape_class == ESCAPE_GLOBAL) {
        1:  228:                ds_printf(all_frees, "  // %s escapes to return - no free\n", b->sym->s);
        -:  229:            } else {
        4:  230:                DString* temp = ds_new();
       4*:  231:                ds_printf(temp, "  %s(%s); // ASAP Clean (shape: %s)\n",
        4:  232:                        free_fn, b->sym->s,
        -:  233:                        var_shape == SHAPE_TREE ? "TREE" :
    #####:  234:                        var_shape == SHAPE_DAG ? "DAG" :
    #####:  235:                        var_shape == SHAPE_CYCLIC ? "CYCLIC" : "UNKNOWN");
        4:  236:                ds_append(temp, ds_cstr(all_frees));
        4:  237:                ds_free(all_frees);
        4:  238:                all_frees = temp;
        -:  239:            }
        -:  240:
        6:  241:            Value* ref = mk_code(b->sym->s);
        6:  242:            new_env = env_extend(new_env, b->sym, ref);
        -:  243:
       6*:  244:            if (b->val->tag != T_CODE) free(val_str);
        6:  245:            b = b->next;
        -:  246:        }
        -:  247:
        5:  248:        Value* body_menv = mk_menv(menv->menv.parent, new_env);
        5:  249:        body_menv->menv.h_app = menv->menv.h_app;
        5:  250:        body_menv->menv.h_let = menv->menv.h_let;
        -:  251:
        5:  252:        Value* res = eval(body, body_menv);
        5:  253:        char* sres = (res->tag == T_CODE) ? res->s : val_to_str(res);
        -:  254:
        5:  255:        DString* block = ds_new();
        5:  256:        ds_printf(block, "({\n%s  Obj* _res = %s;\n%s  _res;\n})",
        -:  257:                  ds_cstr(all_decls), sres, ds_cstr(all_frees));
        -:  258:
        5:  259:        if (res->tag != T_CODE) free(sres);
        -:  260:
        5:  261:        ds_free(all_decls);
        5:  262:        ds_free(all_frees);
        -:  263:
       11:  264:        while (bind_list) {
        6:  265:            BindingInfo* next = bind_list->next;
        6:  266:            free(bind_list);
        6:  267:            bind_list = next;
        -:  268:        }
        -:  269:
        5:  270:        return mk_code(ds_take(block));
        -:  271:    }
        -:  272:
        1:  273:    BindingInfo* b = bind_list;
        3:  274:    while (b) {
        2:  275:        new_env = env_extend(new_env, b->sym, b->val);
        2:  276:        b = b->next;
        -:  277:    }
        -:  278:
        1:  279:    Value* body_menv = mk_menv(menv->menv.parent, new_env);
        1:  280:    body_menv->menv.h_app = menv->menv.h_app;
        1:  281:    body_menv->menv.h_let = menv->menv.h_let;
        -:  282:
        3:  283:    while (bind_list) {
        2:  284:        BindingInfo* next = bind_list->next;
        2:  285:        free(bind_list);
        2:  286:        bind_list = next;
        -:  287:    }
        -:  288:
        1:  289:    return eval(body, body_menv);
        -:  290:}
        -:  291:
        7:  292:Value* h_if_default(Value* exp, Value* menv) {
        7:  293:    Value* args = cdr(exp);
        7:  294:    Value* cond_expr = car(args);
        7:  295:    Value* then_expr = car(cdr(args));
        7:  296:    Value* else_expr = car(cdr(cdr(args)));
        -:  297:
        7:  298:    Value* c = eval(cond_expr, menv);
        -:  299:
        7:  300:    if (is_code(c)) {
        1:  301:        Value* t = eval(then_expr, menv);
        1:  302:        Value* e = eval(else_expr, menv);
       1*:  303:        char* st = (t->tag == T_CODE) ? t->s : val_to_str(t);
       1*:  304:        char* se = (e->tag == T_CODE) ? e->s : val_to_str(e);
        1:  305:        DString* ds = ds_new();
        1:  306:        ds_printf(ds, "((%s)->i ? (%s) : (%s))", c->s, st, se);
       1*:  307:        if (t->tag != T_CODE) free(st);
       1*:  308:        if (e->tag != T_CODE) free(se);
        1:  309:        return mk_code(ds_take(ds));
        -:  310:    }
        -:  311:
        6:  312:    if (!is_nil(c)) return eval(then_expr, menv);
        5:  313:    else return eval(else_expr, menv);
        -:  314:}
        -:  315:
        -:  316:// -- Evaluator --
        -:  317:
      349:  318:Value* eval(Value* expr, Value* menv) {
     349*:  319:    if (is_nil(expr)) return NIL;
     349*:  320:    if (!menv) return NIL;  // NULL check for menv
      349:  321:    if (expr->tag == T_INT) return menv->menv.h_lit(expr, menv);
     227*:  322:    if (expr->tag == T_CODE) return expr;
        -:  323:
      227:  324:    if (expr->tag == T_SYM) {
       79:  325:        return menv->menv.h_var(expr, menv);
        -:  326:    }
        -:  327:
      148:  328:    if (expr->tag == T_CELL) {
      148:  329:        Value* op = car(expr);
      148:  330:        Value* args = cdr(expr);
        -:  331:
      148:  332:        if (sym_eq(op, SYM_QUOTE)) return car(args);
      147:  333:        if (sym_eq(op, SYM_LIFT)) return lift_value(eval(car(args), menv));
        -:  334:
       67:  335:        if (sym_eq(op, SYM_IF)) return menv->menv.h_if(expr, menv);
       60:  336:        if (sym_eq(op, SYM_LET)) return menv->menv.h_let(expr, menv);
        -:  337:
        -:  338:        // letrec - recursive let binding
       54:  339:        if (sym_eq(op, SYM_LETREC)) {
        1:  340:            Value* bindings = car(args);
        1:  341:            Value* body = car(cdr(args));
        -:  342:
        -:  343:            // First pass: extend env with placeholders
        1:  344:            Value* new_env = menv->menv.env;
        1:  345:            Value* b = bindings;
        2:  346:            while (!is_nil(b)) {
        1:  347:                Value* bind = car(b);
        1:  348:                Value* sym = car(bind);
        1:  349:                new_env = env_extend(new_env, sym, NIL);  // Placeholder
        1:  350:                b = cdr(b);
        -:  351:            }
        -:  352:
        -:  353:            // Create new menv for evaluating bindings
        1:  354:            Value* rec_menv = mk_menv(menv->menv.parent, new_env);
        1:  355:            rec_menv->menv.h_app = menv->menv.h_app;
        1:  356:            rec_menv->menv.h_let = menv->menv.h_let;
        1:  357:            rec_menv->menv.h_if = menv->menv.h_if;
        -:  358:
        -:  359:            // Second pass: evaluate and update bindings
        1:  360:            b = bindings;
        1:  361:            Value* env_ptr = new_env;
        2:  362:            while (!is_nil(b)) {
        1:  363:                Value* bind = car(b);
        1:  364:                Value* val_expr = car(cdr(bind));
        1:  365:                Value* val = eval(val_expr, rec_menv);
        -:  366:
        -:  367:                // Update the placeholder in environment
        -:  368:                // Find and update the binding
        1:  369:                Value* e = new_env;
        1:  370:                Value* sym = car(bind);
        1:  371:                while (!is_nil(e)) {
        1:  372:                    Value* pair = car(e);
        1:  373:                    if (sym_eq(car(pair), sym)) {
        1:  374:                        pair->cell.cdr = val;
        1:  375:                        break;
        -:  376:                    }
    #####:  377:                    e = cdr(e);
        -:  378:                }
        1:  379:                b = cdr(b);
        -:  380:            }
        -:  381:
        1:  382:            return eval(body, rec_menv);
        -:  383:        }
        -:  384:
        -:  385:        // Short-circuit and
       53:  386:        if (sym_eq(op, SYM_AND)) {
        2:  387:            Value* rest = args;
        2:  388:            Value* result = SYM_T;
        4:  389:            while (!is_nil(rest)) {
        3:  390:                result = eval(car(rest), menv);
        3:  391:                if (is_code(result)) {
        -:  392:                    // At code level, generate && chain
    #####:  393:                    Value* remaining = cdr(rest);
    #####:  394:                    while (!is_nil(remaining)) {
    #####:  395:                        Value* next = eval(car(remaining), menv);
    #####:  396:                        char* sr = result->s;
    #####:  397:                        char* sn = is_code(next) ? next->s : val_to_str(next);
    #####:  398:                        DString* ds = ds_new();
    #####:  399:                        ds_printf(ds, "(%s && %s)", sr, sn);
    #####:  400:                        if (!is_code(next)) free(sn);
    #####:  401:                        result = mk_code(ds_take(ds));
    #####:  402:                        remaining = cdr(remaining);
        -:  403:                    }
    #####:  404:                    return result;
        -:  405:                }
        3:  406:                if (is_nil(result)) return NIL;
        2:  407:                rest = cdr(rest);
        -:  408:            }
        1:  409:            return result;
        -:  410:        }
        -:  411:
        -:  412:        // Short-circuit or
       51:  413:        if (sym_eq(op, SYM_OR)) {
        2:  414:            Value* rest = args;
        3:  415:            while (!is_nil(rest)) {
        3:  416:                Value* result = eval(car(rest), menv);
        3:  417:                if (is_code(result)) {
        -:  418:                    // At code level, generate || chain
    #####:  419:                    Value* remaining = cdr(rest);
    #####:  420:                    while (!is_nil(remaining)) {
    #####:  421:                        Value* next = eval(car(remaining), menv);
    #####:  422:                        char* sr = result->s;
    #####:  423:                        char* sn = is_code(next) ? next->s : val_to_str(next);
    #####:  424:                        DString* ds = ds_new();
    #####:  425:                        ds_printf(ds, "(%s || %s)", sr, sn);
    #####:  426:                        if (!is_code(next)) free(sn);
    #####:  427:                        result = mk_code(ds_take(ds));
    #####:  428:                        remaining = cdr(remaining);
        -:  429:                    }
    #####:  430:                    return result;
        -:  431:                }
        3:  432:                if (!is_nil(result)) return result;
        1:  433:                rest = cdr(rest);
        -:  434:            }
    #####:  435:            return NIL;
        -:  436:        }
        -:  437:
       49:  438:        if (sym_eq(op, SYM_LAMBDA)) {
        2:  439:            Value* params = car(args);
        2:  440:            Value* body = car(cdr(args));
        2:  441:            return mk_lambda(params, body, menv->menv.env);
        -:  442:        }
        -:  443:
       47:  444:        if (sym_eq(op, SYM_EM)) {
    #####:  445:            Value* e = car(args);
    #####:  446:            Value* parent = menv->menv.parent;
    #####:  447:            if (is_nil(parent)) {
    #####:  448:                parent = mk_menv(NIL, NIL);
    #####:  449:                menv->menv.parent = parent;
        -:  450:            }
    #####:  451:            return eval(e, parent);
        -:  452:        }
        -:  453:
       47:  454:        if (sym_eq(op, SYM_SET_META)) {
    #####:  455:            Value* key = eval(car(args), menv);
    #####:  456:            if (key->tag != T_SYM) key = car(args);
    #####:  457:            Value* val = eval(car(cdr(args)), menv);
    #####:  458:            if (sym_eq_str(key, "add")) {
    #####:  459:                menv->menv.env = env_extend(menv->menv.env, mk_sym("+"), val);
        -:  460:            }
    #####:  461:            return NIL;
        -:  462:        }
        -:  463:
       47:  464:        if (sym_eq(op, SYM_SCAN)) {
        1:  465:            Value* type_sym = eval(car(args), menv);
        1:  466:            Value* val = eval(car(cdr(args)), menv);
       1*:  467:            char* sval = (val->tag == T_CODE) ? val->s : val_to_str(val);
        1:  468:            DString* ds = ds_new();
        1:  469:            ds_printf(ds, "scan_%s(%s); // ASAP Mark", type_sym->s, sval);
       1*:  470:            if (val->tag != T_CODE) free(sval);
        1:  471:            return mk_code(ds_take(ds));
        -:  472:        }
        -:  473:
       46:  474:        return menv->menv.h_app(expr, menv);
        -:  475:    }
    #####:  476:    return NIL;
        -:  477:}
        -:  478:
        -:  479:// -- Primitives --
        -:  480:
        -:  481:// Helper: safely get two int args, return 0 on error
       34:  482:static int get_two_args(Value* args, Value** a, Value** b) {
      34*:  483:    if (!args || is_nil(args)) return 0;
       34:  484:    *a = car(args);
      34*:  485:    if (!*a) return 0;
       34:  486:    Value* rest = cdr(args);
      34*:  487:    if (!rest || is_nil(rest)) return 0;
       34:  488:    *b = car(rest);
      34*:  489:    if (!*b) return 0;
       34:  490:    return 1;
        -:  491:}
        -:  492:
        6:  493:Value* prim_add(Value* args, Value* menv) {
        -:  494:    Value* a; Value* b;
       6*:  495:    if (!get_two_args(args, &a, &b)) return NIL;
        6:  496:    if (is_code(a) || is_code(b)) return emit_c_call("add", a, b);
       2*:  497:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
        2:  498:    return mk_int(a->i + b->i);
        -:  499:}
        -:  500:
        5:  501:Value* prim_sub(Value* args, Value* menv) {
        -:  502:    Value* a; Value* b;
       5*:  503:    if (!get_two_args(args, &a, &b)) return NIL;
       5*:  504:    if (is_code(a) || is_code(b)) return emit_c_call("sub", a, b);
       5*:  505:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
        5:  506:    return mk_int(a->i - b->i);
        -:  507:}
        -:  508:
        4:  509:Value* prim_cons(Value* args, Value* menv) {
        -:  510:    Value* a; Value* b;
       4*:  511:    if (!get_two_args(args, &a, &b)) return NIL;
       4*:  512:    if (is_code(a) || is_code(b)) return emit_c_call("mk_pair", a, b);
        4:  513:    return mk_cell(a, b);
        -:  514:}
        -:  515:
    #####:  516:Value* prim_run(Value* args, Value* menv) {
    #####:  517:    Value* a = car(args);
    #####:  518:    if (!a) return NIL;
    #####:  519:    return eval(a, menv);
        -:  520:}
        -:  521:
        -:  522:// -- Additional Arithmetic Primitives --
        -:  523:
        6:  524:Value* prim_mul(Value* args, Value* menv) {
        -:  525:    (void)menv;
        -:  526:    Value* a; Value* b;
       6*:  527:    if (!get_two_args(args, &a, &b)) return NIL;
       6*:  528:    if (is_code(a) || is_code(b)) return emit_c_call("mul", a, b);
       6*:  529:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
        6:  530:    return mk_int(a->i * b->i);
        -:  531:}
        -:  532:
        1:  533:Value* prim_div(Value* args, Value* menv) {
        -:  534:    (void)menv;
        -:  535:    Value* a; Value* b;
       1*:  536:    if (!get_two_args(args, &a, &b)) return NIL;
       1*:  537:    if (is_code(a) || is_code(b)) return emit_c_call("div_op", a, b);
       1*:  538:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
       1*:  539:    if (b->i == 0) return mk_int(0);
        1:  540:    return mk_int(a->i / b->i);
        -:  541:}
        -:  542:
        1:  543:Value* prim_mod(Value* args, Value* menv) {
        -:  544:    (void)menv;
        -:  545:    Value* a; Value* b;
       1*:  546:    if (!get_two_args(args, &a, &b)) return NIL;
       1*:  547:    if (is_code(a) || is_code(b)) return emit_c_call("mod_op", a, b);
       1*:  548:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
       1*:  549:    if (b->i == 0) return mk_int(0);
        1:  550:    return mk_int(a->i % b->i);
        -:  551:}
        -:  552:
        -:  553:// -- Comparison Primitives --
        -:  554:
        7:  555:Value* prim_eq(Value* args, Value* menv) {
        -:  556:    (void)menv;
        -:  557:    Value* a; Value* b;
       7*:  558:    if (!get_two_args(args, &a, &b)) return NIL;
       7*:  559:    if (is_code(a) || is_code(b)) return emit_c_call("eq_op", a, b);
        -:  560:    // Handle different types
        7:  561:    if (a->tag == T_INT && b->tag == T_INT) {
        7:  562:        return a->i == b->i ? SYM_T : NIL;
        -:  563:    }
    #####:  564:    if (a->tag == T_SYM && b->tag == T_SYM) {
    #####:  565:        return sym_eq(a, b) ? SYM_T : NIL;
        -:  566:    }
    #####:  567:    if (a->tag == T_NIL && b->tag == T_NIL) return SYM_T;
    #####:  568:    return NIL;
        -:  569:}
        -:  570:
        1:  571:Value* prim_lt(Value* args, Value* menv) {
        -:  572:    (void)menv;
        -:  573:    Value* a; Value* b;
       1*:  574:    if (!get_two_args(args, &a, &b)) return NIL;
       1*:  575:    if (is_code(a) || is_code(b)) return emit_c_call("lt_op", a, b);
       1*:  576:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
       1*:  577:    return a->i < b->i ? SYM_T : NIL;
        -:  578:}
        -:  579:
        1:  580:Value* prim_gt(Value* args, Value* menv) {
        -:  581:    (void)menv;
        -:  582:    Value* a; Value* b;
       1*:  583:    if (!get_two_args(args, &a, &b)) return NIL;
       1*:  584:    if (is_code(a) || is_code(b)) return emit_c_call("gt_op", a, b);
       1*:  585:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
       1*:  586:    return a->i > b->i ? SYM_T : NIL;
        -:  587:}
        -:  588:
        1:  589:Value* prim_le(Value* args, Value* menv) {
        -:  590:    (void)menv;
        -:  591:    Value* a; Value* b;
       1*:  592:    if (!get_two_args(args, &a, &b)) return NIL;
       1*:  593:    if (is_code(a) || is_code(b)) return emit_c_call("le_op", a, b);
       1*:  594:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
       1*:  595:    return a->i <= b->i ? SYM_T : NIL;
        -:  596:}
        -:  597:
        1:  598:Value* prim_ge(Value* args, Value* menv) {
        -:  599:    (void)menv;
        -:  600:    Value* a; Value* b;
       1*:  601:    if (!get_two_args(args, &a, &b)) return NIL;
       1*:  602:    if (is_code(a) || is_code(b)) return emit_c_call("ge_op", a, b);
       1*:  603:    if (a->tag != T_INT || b->tag != T_INT) return NIL;
       1*:  604:    return a->i >= b->i ? SYM_T : NIL;
        -:  605:}
        -:  606:
        -:  607:// -- Logical Primitives --
        -:  608:
        1:  609:Value* prim_not(Value* args, Value* menv) {
        -:  610:    (void)menv;
       1*:  611:    if (!args || is_nil(args)) return SYM_T;  // not of nothing is true
        1:  612:    Value* a = car(args);
       1*:  613:    if (!a) return SYM_T;
       1*:  614:    if (is_code(a)) return emit_c_call("not_op", a, NIL);
       1*:  615:    return is_nil(a) ? SYM_T : NIL;
        -:  616:}
        -:  617:
        -:  618:// -- List Primitives --
        -:  619:
        -:  620:// Helper: safely get one arg
        5:  621:static Value* get_one_arg(Value* args) {
       5*:  622:    if (!args || is_nil(args)) return NULL;
        5:  623:    return car(args);
        -:  624:}
        -:  625:
        2:  626:Value* prim_car(Value* args, Value* menv) {
        -:  627:    (void)menv;
        2:  628:    Value* a = get_one_arg(args);
       2*:  629:    if (!a) return NIL;
        2:  630:    if (is_code(a)) {
    #####:  631:        DString* ds = ds_new();
    #####:  632:        ds_printf(ds, "(%s)->a", a->s);
    #####:  633:        return mk_code(ds_take(ds));
        -:  634:    }
       2*:  635:    if (a->tag != T_CELL) return NIL;
        2:  636:    return car(a);
        -:  637:}
        -:  638:
        2:  639:Value* prim_cdr(Value* args, Value* menv) {
        -:  640:    (void)menv;
        2:  641:    Value* a = get_one_arg(args);
       2*:  642:    if (!a) return NIL;
        2:  643:    if (is_code(a)) {
    #####:  644:        DString* ds = ds_new();
    #####:  645:        ds_printf(ds, "(%s)->b", a->s);
    #####:  646:        return mk_code(ds_take(ds));
        -:  647:    }
       2*:  648:    if (a->tag != T_CELL) return NIL;
        2:  649:    return cdr(a);
        -:  650:}
        -:  651:
        -:  652:// fst and snd are aliases for car and cdr
        1:  653:Value* prim_fst(Value* args, Value* menv) {
        1:  654:    return prim_car(args, menv);
        -:  655:}
        -:  656:
        1:  657:Value* prim_snd(Value* args, Value* menv) {
        1:  658:    return prim_cdr(args, menv);
        -:  659:}
        -:  660:
        1:  661:Value* prim_null(Value* args, Value* menv) {
        -:  662:    (void)menv;
        1:  663:    Value* a = get_one_arg(args);
       1*:  664:    if (!a) return SYM_T;  // null? of nothing is true
        1:  665:    if (is_code(a)) {
    #####:  666:        DString* ds = ds_new();
    #####:  667:        ds_printf(ds, "is_nil(%s)", a->s);
    #####:  668:        return mk_code(ds_take(ds));
        -:  669:    }
       1*:  670:    return is_nil(a) ? SYM_T : NIL;
        -:  671:}
