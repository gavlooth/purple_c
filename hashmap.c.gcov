        -:    0:Source:src/util/hashmap.c
        -:    1:#include "hashmap.h"
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:#define INITIAL_BUCKETS 64
        -:    6:#define MAX_LOAD_FACTOR 0.75f
        -:    7:
        -:    8:// Hash function for pointers (uses FNV-1a style mixing)
    #####:    9:static size_t hash_ptr(void* ptr) {
    #####:   10:    uintptr_t x = (uintptr_t)ptr;
        -:   11:    // Mix the bits
    #####:   12:    x = ((x >> 16) ^ x) * 0x45d9f3b;
    #####:   13:    x = ((x >> 16) ^ x) * 0x45d9f3b;
    #####:   14:    x = (x >> 16) ^ x;
    #####:   15:    return (size_t)x;
        -:   16:}
        -:   17:
        -:   18:// Create with default capacity
    #####:   19:HashMap* hashmap_new(void) {
    #####:   20:    return hashmap_with_capacity(INITIAL_BUCKETS);
        -:   21:}
        -:   22:
        -:   23:// Create with specified capacity
    #####:   24:HashMap* hashmap_with_capacity(size_t capacity) {
    #####:   25:    HashMap* map = malloc(sizeof(HashMap));
    #####:   26:    if (!map) return NULL;
        -:   27:
    #####:   28:    if (capacity < 16) capacity = 16;
        -:   29:
    #####:   30:    map->buckets = calloc(capacity, sizeof(HashEntry*));
    #####:   31:    if (!map->buckets) {
    #####:   32:        free(map);
    #####:   33:        return NULL;
        -:   34:    }
        -:   35:
    #####:   36:    map->bucket_count = capacity;
    #####:   37:    map->entry_count = 0;
    #####:   38:    map->load_factor = MAX_LOAD_FACTOR;
    #####:   39:    return map;
        -:   40:}
        -:   41:
        -:   42:// Free hash map
    #####:   43:void hashmap_free(HashMap* map) {
    #####:   44:    if (!map) return;
    #####:   45:    hashmap_free_entries(map);
    #####:   46:    free(map->buckets);
    #####:   47:    free(map);
        -:   48:}
        -:   49:
        -:   50:// Free all entries
    #####:   51:void hashmap_free_entries(HashMap* map) {
    #####:   52:    if (!map) return;
        -:   53:
    #####:   54:    for (size_t i = 0; i < map->bucket_count; i++) {
    #####:   55:        HashEntry* entry = map->buckets[i];
    #####:   56:        while (entry) {
    #####:   57:            HashEntry* next = entry->next;
    #####:   58:            free(entry);
    #####:   59:            entry = next;
        -:   60:        }
    #####:   61:        map->buckets[i] = NULL;
        -:   62:    }
    #####:   63:    map->entry_count = 0;
        -:   64:}
        -:   65:
        -:   66:// Resize when load factor exceeded
    #####:   67:static void hashmap_resize(HashMap* map) {
    #####:   68:    size_t new_count = map->bucket_count * 2;
    #####:   69:    HashEntry** new_buckets = calloc(new_count, sizeof(HashEntry*));
    #####:   70:    if (!new_buckets) return;  // Keep old buckets on failure
        -:   71:
        -:   72:    // Rehash all entries
    #####:   73:    for (size_t i = 0; i < map->bucket_count; i++) {
    #####:   74:        HashEntry* entry = map->buckets[i];
    #####:   75:        while (entry) {
    #####:   76:            HashEntry* next = entry->next;
    #####:   77:            size_t idx = hash_ptr(entry->key) % new_count;
    #####:   78:            entry->next = new_buckets[idx];
    #####:   79:            new_buckets[idx] = entry;
    #####:   80:            entry = next;
        -:   81:        }
        -:   82:    }
        -:   83:
    #####:   84:    free(map->buckets);
    #####:   85:    map->buckets = new_buckets;
    #####:   86:    map->bucket_count = new_count;
        -:   87:}
        -:   88:
        -:   89:// Get value by key
    #####:   90:void* hashmap_get(HashMap* map, void* key) {
    #####:   91:    if (!map) return NULL;
        -:   92:
    #####:   93:    size_t idx = hash_ptr(key) % map->bucket_count;
    #####:   94:    HashEntry* entry = map->buckets[idx];
        -:   95:
    #####:   96:    while (entry) {
    #####:   97:        if (entry->key == key) return entry->value;
    #####:   98:        entry = entry->next;
        -:   99:    }
    #####:  100:    return NULL;
        -:  101:}
        -:  102:
        -:  103:// Put key-value pair
    #####:  104:void hashmap_put(HashMap* map, void* key, void* value) {
    #####:  105:    if (!map) return;
        -:  106:
        -:  107:    // Check if need to resize
    #####:  108:    if ((float)map->entry_count / map->bucket_count > map->load_factor) {
    #####:  109:        hashmap_resize(map);
        -:  110:    }
        -:  111:
    #####:  112:    size_t idx = hash_ptr(key) % map->bucket_count;
    #####:  113:    HashEntry* entry = map->buckets[idx];
        -:  114:
        -:  115:    // Check if key exists
    #####:  116:    while (entry) {
    #####:  117:        if (entry->key == key) {
    #####:  118:            entry->value = value;
    #####:  119:            return;
        -:  120:        }
    #####:  121:        entry = entry->next;
        -:  122:    }
        -:  123:
        -:  124:    // Create new entry
    #####:  125:    entry = malloc(sizeof(HashEntry));
    #####:  126:    if (!entry) return;
        -:  127:
    #####:  128:    entry->key = key;
    #####:  129:    entry->value = value;
    #####:  130:    entry->next = map->buckets[idx];
    #####:  131:    map->buckets[idx] = entry;
    #####:  132:    map->entry_count++;
        -:  133:}
        -:  134:
        -:  135:// Remove key
    #####:  136:void* hashmap_remove(HashMap* map, void* key) {
    #####:  137:    if (!map) return NULL;
        -:  138:
    #####:  139:    size_t idx = hash_ptr(key) % map->bucket_count;
    #####:  140:    HashEntry** prev = &map->buckets[idx];
    #####:  141:    HashEntry* entry = *prev;
        -:  142:
    #####:  143:    while (entry) {
    #####:  144:        if (entry->key == key) {
    #####:  145:            void* value = entry->value;
    #####:  146:            *prev = entry->next;
    #####:  147:            free(entry);
    #####:  148:            map->entry_count--;
    #####:  149:            return value;
        -:  150:        }
    #####:  151:        prev = &entry->next;
    #####:  152:        entry = entry->next;
        -:  153:    }
    #####:  154:    return NULL;
        -:  155:}
        -:  156:
        -:  157:// Check if key exists
    #####:  158:int hashmap_contains(HashMap* map, void* key) {
    #####:  159:    if (!map) return 0;
        -:  160:
    #####:  161:    size_t idx = hash_ptr(key) % map->bucket_count;
    #####:  162:    HashEntry* entry = map->buckets[idx];
        -:  163:
    #####:  164:    while (entry) {
    #####:  165:        if (entry->key == key) return 1;
    #####:  166:        entry = entry->next;
        -:  167:    }
    #####:  168:    return 0;
        -:  169:}
        -:  170:
        -:  171:// Iterate over all entries
    #####:  172:void hashmap_foreach(HashMap* map, HashMapIterFn fn, void* ctx) {
    #####:  173:    if (!map || !fn) return;
        -:  174:
    #####:  175:    for (size_t i = 0; i < map->bucket_count; i++) {
    #####:  176:        HashEntry* entry = map->buckets[i];
    #####:  177:        while (entry) {
    #####:  178:            fn(entry->key, entry->value, ctx);
    #####:  179:            entry = entry->next;
        -:  180:        }
        -:  181:    }
        -:  182:}
        -:  183:
        -:  184:// Get entry count
    #####:  185:size_t hashmap_size(HashMap* map) {
    #####:  186:    return map ? map->entry_count : 0;
        -:  187:}
        -:  188:
        -:  189:// Clear all entries
    #####:  190:void hashmap_clear(HashMap* map) {
    #####:  191:    hashmap_free_entries(map);
    #####:  192:}
