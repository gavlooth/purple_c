        -:    0:Source:src/main.c
        -:    1:/*
        -:    2: * ============================================================================
        -:    3: * Purple C Compiler - ASAP + ISMM 2024 Memory Management
        -:    4: *
        -:    5: * Primary Strategy:
        -:    6: *   - ASAP (As Static As Possible): Compile-time free insertion for acyclic data
        -:    7: *   - ISMM 2024 (Deeply Immutable Cycles): SCC-based RC for frozen cyclic data
        -:    8: *   - Deferred RC Fallback: Bounded O(k) processing for mutable cycles
        -:    9: *
        -:   10: * Zero-pause guarantee: No stop-the-world GC, O(k) bounded work
        -:   11: * ============================================================================
        -:   12: */
        -:   13:
        -:   14:#include <stdio.h>
        -:   15:#include <ctype.h>
        -:   16:#include <string.h>
        -:   17:
        -:   18:#include "types.h"
        -:   19:#include "eval/eval.h"
        -:   20:#include "parser/parser.h"
        -:   21:#include "codegen/codegen.h"
        -:   22:#include "memory/scc.h"
        -:   23:#include "memory/deferred.h"
        -:   24:#include "memory/arena.h"
        -:   25:#include "memory/exception.h"
        -:   26:#include "memory/concurrent.h"
        -:   27:#include "analysis/shape.h"
        -:   28:#include "analysis/escape.h"
        -:   29:#include "analysis/dps.h"
        -:   30:
        -:   31:// -- Main Entry Point --
        -:   32:
       98:   33:int main(int argc, char** argv) {
        -:   34:    // Initialize compiler arena (Phase 12)
        -:   35:    // All Value* allocations during compilation use this arena
       98:   36:    compiler_arena_init();
        -:   37:
        -:   38:    // Initialize symbol table
       98:   39:    init_syms();
        -:   40:
        -:   41:    // Initialize type registry (Phase 8)
       98:   42:    init_type_registry();
        -:   43:
        -:   44:    // Initial environment with primitives
       98:   45:    Value* env = NIL;
        -:   46:
        -:   47:    // Constants
       98:   48:    env = env_extend(env, mk_sym("t"), SYM_T);
       98:   49:    env = env_extend(env, mk_sym("nil"), NIL);
        -:   50:
        -:   51:    // Arithmetic
       98:   52:    env = env_extend(env, mk_sym("+"), mk_prim(prim_add));
       98:   53:    env = env_extend(env, mk_sym("-"), mk_prim(prim_sub));
       98:   54:    env = env_extend(env, mk_sym("*"), mk_prim(prim_mul));
       98:   55:    env = env_extend(env, mk_sym("/"), mk_prim(prim_div));
       98:   56:    env = env_extend(env, mk_sym("%"), mk_prim(prim_mod));
        -:   57:
        -:   58:    // Comparison
       98:   59:    env = env_extend(env, mk_sym("="), mk_prim(prim_eq));
       98:   60:    env = env_extend(env, mk_sym("<"), mk_prim(prim_lt));
       98:   61:    env = env_extend(env, mk_sym(">"), mk_prim(prim_gt));
       98:   62:    env = env_extend(env, mk_sym("<="), mk_prim(prim_le));
       98:   63:    env = env_extend(env, mk_sym(">="), mk_prim(prim_ge));
        -:   64:
        -:   65:    // Logical
       98:   66:    env = env_extend(env, mk_sym("not"), mk_prim(prim_not));
        -:   67:
        -:   68:    // List operations
       98:   69:    env = env_extend(env, mk_sym("cons"), mk_prim(prim_cons));
       98:   70:    env = env_extend(env, mk_sym("car"), mk_prim(prim_car));
       98:   71:    env = env_extend(env, mk_sym("cdr"), mk_prim(prim_cdr));
       98:   72:    env = env_extend(env, mk_sym("fst"), mk_prim(prim_fst));
       98:   73:    env = env_extend(env, mk_sym("snd"), mk_prim(prim_snd));
       98:   74:    env = env_extend(env, mk_sym("null?"), mk_prim(prim_null));
        -:   75:
        -:   76:    // Other
       98:   77:    env = env_extend(env, mk_sym("run"), mk_prim(prim_run));
        -:   78:
        -:   79:    // Initial Meta-Environment (Level 0)
       98:   80:    Value* menv = mk_menv(NIL, env);
        -:   81:
        -:   82:    // Generate C runtime header
       98:   83:    gen_runtime_header();
        -:   84:
        -:   85:    // Generate weak reference support (Phase 3)
       98:   86:    gen_weak_ref_runtime();
        -:   87:
        -:   88:    // Generate Perceus reuse runtime (Phase 4)
       98:   89:    gen_perceus_runtime();
        -:   90:
        -:   91:    // Generate SCC runtime (Phase 6b - ISMM 2024)
       98:   92:    gen_scc_runtime();
        -:   93:
        -:   94:    // Generate deferred RC runtime (Phase 7)
       98:   95:    gen_deferred_runtime();
        -:   96:
        -:   97:    // Generate arena allocator (Phase 8)
       98:   98:    gen_arena_runtime();
        -:   99:
        -:  100:    // Generate DPS runtime (Phase 9)
       98:  101:    gen_dps_runtime();
        -:  102:
        -:  103:    // Generate exception handling runtime (Phase 10)
       98:  104:    gen_exception_runtime();
        -:  105:
        -:  106:    // Generate concurrency runtime (Phase 11)
       98:  107:    gen_concurrent_runtime();
        -:  108:
        -:  109:    // Generate ASAP scanner for List type
       98:  110:    gen_asap_scanner("List", 1);
        -:  111:
       98:  112:    printf("\n// Runtime arithmetic functions\n");
       98:  113:    printf("Obj* add(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i + b->i); }\n");
       98:  114:    printf("Obj* sub(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i - b->i); }\n");
       98:  115:    printf("Obj* mul(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i * b->i); }\n");
       98:  116:    printf("Obj* div_op(Obj* a, Obj* b) { if (!a || !b || b->i == 0) return mk_int(0); return mk_int(a->i / b->i); }\n");
       98:  117:    printf("Obj* mod_op(Obj* a, Obj* b) { if (!a || !b || b->i == 0 || (a->i == LONG_MIN && b->i == -1)) return mk_int(0); return mk_int(a->i %% b->i); }\n\n");
        -:  118:
       98:  119:    printf("// Runtime comparison functions\n");
       98:  120:    printf("Obj* eq_op(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i == b->i); }\n");
       98:  121:    printf("Obj* lt_op(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i < b->i); }\n");
       98:  122:    printf("Obj* gt_op(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i > b->i); }\n");
       98:  123:    printf("Obj* le_op(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i <= b->i); }\n");
       98:  124:    printf("Obj* ge_op(Obj* a, Obj* b) { if (!a || !b) return mk_int(0); return mk_int(a->i >= b->i); }\n\n");
        -:  125:
       98:  126:    printf("// Runtime logical functions\n");
       98:  127:    printf("Obj* not_op(Obj* a, Obj* unused) { (void)unused; if (!a) return mk_int(1); return mk_int(!a->i); }\n\n");
        -:  128:
       98:  129:    printf("// Runtime list functions\n");
       98:  130:    printf("int is_nil(Obj* x) { return x == NULL; }\n\n");
        -:  131:
       98:  132:    printf("int main() {\n");
        -:  133:
        -:  134:    // Process input expressions
       98:  135:    char* input_str = NULL;
       98:  136:    int input_allocated = 0;
        -:  137:
       98:  138:    if (argc > 1) {
        -:  139:        // Read from command line argument
       14:  140:        input_str = argv[1];
        -:  141:    } else {
        -:  142:        // Read from stdin using dynamic buffer
       84:  143:        size_t cap = 1024;
       84:  144:        size_t len = 0;
       84:  145:        char* buf = malloc(cap);
      84*:  146:        if (!buf) { fprintf(stderr, "OOM\n"); return 1; }
        -:  147:        
        -:  148:        int c;
     1016:  149:        while ((c = getchar()) != EOF && c != '\n') {
      932:  150:            if (len + 1 >= cap) {
    #####:  151:                cap *= 2;
    #####:  152:                buf = realloc(buf, cap);
    #####:  153:                if (!buf) { fprintf(stderr, "OOM\n"); return 1; }
        -:  154:            }
      932:  155:            buf[len++] = (char)c;
        -:  156:        }
       84:  157:        buf[len] = '\0';
       84:  158:        input_str = buf;
       84:  159:        input_allocated = 1;
        -:  160:    }
        -:  161:
      196:  162:    if (input_str && strlen(input_str) > 0) {
       98:  163:        set_parse_input(input_str);
       98:  164:        Value* expr = parse();
       98:  165:        if (expr) {
       98:  166:            Value* result = eval(expr, menv);
       98:  167:            char* str = val_to_str(result);
       98:  168:            if (result->tag == T_CODE) {
        -:  169:                // Compiled code - output as expression
       77:  170:                printf("  // Expression: %s\n", input_str);
       77:  171:                printf("  Obj* result = %s;\n", str);
       77:  172:                printf("  printf(\"Result: %%ld\\n\", result->i);\n");
       21:  173:            } else if (result->tag == T_INT) {
        -:  174:                // Interpreted result - output as comment
       10:  175:                printf("  // Result: %ld\n", result->i);
        -:  176:            } else {
        -:  177:                // Other result types
       11:  178:                printf("  // Result: %s\n", str);
        -:  179:            }
       98:  180:            free(str);
        -:  181:        }
        -:  182:    } else {
        -:  183:        // Default test expression
    #####:  184:        const char* test = "(let ((x (lift 10))) (+ x (lift 5)))";
    #####:  185:        printf("  // Default test: %s\n", test);
    #####:  186:        set_parse_input(test);
    #####:  187:        Value* expr = parse();
    #####:  188:        if (expr) {
    #####:  189:            Value* result = eval(expr, menv);
    #####:  190:            char* str = val_to_str(result);
    #####:  191:            printf("  Obj* result = %s;\n", str);
    #####:  192:            printf("  printf(\"Result: %%ld\\n\", result->i);\n");
    #####:  193:            free(str);
        -:  194:        }
        -:  195:    }
        -:  196:    
       98:  197:    if (input_allocated) free(input_str);
        -:  198:
       98:  199:    printf("  flush_freelist();\n");
       98:  200:    printf("  flush_all_deferred();\n");
       98:  201:    printf("  return 0;\n");
       98:  202:    printf("}\n");
        -:  203:
        -:  204:    // Cleanup compiler arena - bulk free all Values and strings
       98:  205:    compiler_arena_cleanup();
        -:  206:
       98:  207:    return 0;
        -:  208:}
