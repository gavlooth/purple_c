        -:    0:Source:src/memory/scc.c
        -:    1:#include "scc.h"
        -:    2:#include <stdio.h>
        -:    3:
        -:    4:// -- SCC Registry Management --
        -:    5:
    #####:    6:SCCRegistry* mk_scc_registry(void) {
    #####:    7:    SCCRegistry* reg = malloc(sizeof(SCCRegistry));
    #####:    8:    if (!reg) return NULL;
    #####:    9:    reg->sccs = NULL;
    #####:   10:    reg->next_id = 1;
    #####:   11:    reg->node_map = NULL;
    #####:   12:    reg->node_lookup = hashmap_new();
    #####:   13:    if (!reg->node_lookup) {
    #####:   14:        free(reg);
    #####:   15:        return NULL;
        -:   16:    }
    #####:   17:    reg->stack = NULL;
    #####:   18:    reg->index = 0;
    #####:   19:    return reg;
        -:   20:}
        -:   21:
    #####:   22:void free_scc_registry(SCCRegistry* reg) {
    #####:   23:    if (!reg) return;
        -:   24:
        -:   25:    // Free all SCCs
    #####:   26:    SCC* scc = reg->sccs;
    #####:   27:    while (scc) {
    #####:   28:        SCC* next = scc->next;
    #####:   29:        if (scc->members) free(scc->members);
    #####:   30:        free(scc);
    #####:   31:        scc = next;
        -:   32:    }
        -:   33:
        -:   34:    // Free hash map
    #####:   35:    if (reg->node_lookup) {
    #####:   36:        hashmap_free(reg->node_lookup);
        -:   37:    }
        -:   38:
        -:   39:    // Free node map (linked list for cleanup)
    #####:   40:    SCCNode* node = reg->node_map;
    #####:   41:    while (node) {
    #####:   42:        SCCNode* next = node->next;
    #####:   43:        free(node);
    #####:   44:        node = next;
        -:   45:    }
        -:   46:
    #####:   47:    free(reg);
        -:   48:}
        -:   49:
        -:   50:// -- SCC Operations --
        -:   51:
    #####:   52:SCC* create_scc(SCCRegistry* reg) {
    #####:   53:    if (!reg) return NULL;
    #####:   54:    SCC* scc = malloc(sizeof(SCC));
    #####:   55:    if (!scc) return NULL;
    #####:   56:    scc->members = malloc(16 * sizeof(Obj*));
    #####:   57:    if (!scc->members) {
    #####:   58:        free(scc);
    #####:   59:        return NULL;
        -:   60:    }
    #####:   61:    scc->id = reg->next_id++;
    #####:   62:    scc->member_count = 0;
    #####:   63:    scc->capacity = 16;
    #####:   64:    scc->ref_count = 1;
    #####:   65:    scc->frozen = 0;
    #####:   66:    scc->next = reg->sccs;
    #####:   67:    reg->sccs = scc;
    #####:   68:    return scc;
        -:   69:}
        -:   70:
    #####:   71:void add_to_scc(SCC* scc, Obj* obj) {
    #####:   72:    if (!scc || !obj) return;
    #####:   73:    if (scc->member_count >= scc->capacity) {
    #####:   74:        int new_cap = scc->capacity * 2;
    #####:   75:        Obj** new_members = realloc(scc->members, new_cap * sizeof(Obj*));
    #####:   76:        if (!new_members) return;  // Keep existing data on failure
    #####:   77:        scc->members = new_members;
    #####:   78:        scc->capacity = new_cap;
        -:   79:    }
    #####:   80:    scc->members[scc->member_count++] = obj;
    #####:   81:    obj->scc_id = scc->id;
        -:   82:}
        -:   83:
    #####:   84:SCC* find_scc(SCCRegistry* reg, int scc_id) {
    #####:   85:    SCC* scc = reg->sccs;
    #####:   86:    while (scc) {
    #####:   87:        if (scc->id == scc_id) return scc;
    #####:   88:        scc = scc->next;
        -:   89:    }
    #####:   90:    return NULL;
        -:   91:}
        -:   92:
        -:   93:// -- Tarjan's Algorithm Helpers --
        -:   94:
        -:   95:// O(1) lookup using hash map
    #####:   96:static SCCNode* get_node(SCCRegistry* reg, Obj* obj) {
    #####:   97:    return (SCCNode*)hashmap_get(reg->node_lookup, obj);
        -:   98:}
        -:   99:
    #####:  100:static SCCNode* get_or_create_node(SCCRegistry* reg, Obj* obj) {
    #####:  101:    if (!reg || !obj) return NULL;
    #####:  102:    SCCNode* existing = get_node(reg, obj);
    #####:  103:    if (existing) return existing;
        -:  104:
    #####:  105:    SCCNode* n = malloc(sizeof(SCCNode));
    #####:  106:    if (!n) return NULL;
    #####:  107:    n->id = -1;
    #####:  108:    n->lowlink = -1;
    #####:  109:    n->on_stack = 0;
    #####:  110:    n->obj = obj;
    #####:  111:    n->next = reg->node_map;
    #####:  112:    n->stack_next = NULL;
    #####:  113:    reg->node_map = n;
        -:  114:
        -:  115:    // Add to hash map for O(1) lookup
    #####:  116:    hashmap_put(reg->node_lookup, obj, n);
        -:  117:
    #####:  118:    return n;
        -:  119:}
        -:  120:
    #####:  121:static void push_stack(SCCRegistry* reg, SCCNode* node) {
    #####:  122:    node->stack_next = reg->stack;
    #####:  123:    reg->stack = node;
    #####:  124:    node->on_stack = 1;
    #####:  125:}
        -:  126:
    #####:  127:static SCCNode* pop_stack(SCCRegistry* reg) {
    #####:  128:    if (!reg->stack) return NULL;
    #####:  129:    SCCNode* node = reg->stack;
    #####:  130:    reg->stack = node->stack_next;
    #####:  131:    node->on_stack = 0;
    #####:  132:    return node;
        -:  133:}
        -:  134:
    #####:  135:static int min(int a, int b) {
    #####:  136:    return (a < b) ? a : b;
        -:  137:}
        -:  138:
    #####:  139:static void reset_tarjan_state(SCCRegistry* reg) {
    #####:  140:    if (!reg) return;
        -:  141:
        -:  142:    // Clear node map entries
    #####:  143:    SCCNode* node = reg->node_map;
    #####:  144:    while (node) {
    #####:  145:        SCCNode* next = node->next;
    #####:  146:        free(node);
    #####:  147:        node = next;
        -:  148:    }
    #####:  149:    reg->node_map = NULL;
    #####:  150:    reg->stack = NULL;
    #####:  151:    reg->index = 0;
        -:  152:
    #####:  153:    if (reg->node_lookup) {
    #####:  154:        hashmap_free(reg->node_lookup);
        -:  155:    }
    #####:  156:    reg->node_lookup = hashmap_new();
        -:  157:}
        -:  158:
        -:  159:// -- Tarjan's SCC Algorithm (Iterative with explicit stack) --
        -:  160:
        -:  161:// Work stack frame for iterative Tarjan's
        -:  162:typedef enum { TARJAN_INIT, TARJAN_AFTER_A, TARJAN_AFTER_B, TARJAN_DONE } TarjanState;
        -:  163:
        -:  164:typedef struct TarjanFrame {
        -:  165:    Obj* v;
        -:  166:    SCCNode* node;
        -:  167:    TarjanState state;
        -:  168:    int pushed_a;  // Did we push a frame for child 'a'?
        -:  169:    int pushed_b;  // Did we push a frame for child 'b'?
        -:  170:    struct TarjanFrame* next;
        -:  171:} TarjanFrame;
        -:  172:
    #####:  173:static int push_tarjan_frame(TarjanFrame** work_stack, Obj* v, TarjanState state) {
    #####:  174:    TarjanFrame* frame = malloc(sizeof(TarjanFrame));
    #####:  175:    if (!frame) return 0;  // Allocation failed
    #####:  176:    frame->v = v;
    #####:  177:    frame->node = NULL;
    #####:  178:    frame->state = state;
    #####:  179:    frame->pushed_a = 0;
    #####:  180:    frame->pushed_b = 0;
    #####:  181:    frame->next = *work_stack;
    #####:  182:    *work_stack = frame;
    #####:  183:    return 1;  // Success
        -:  184:}
        -:  185:
    #####:  186:static TarjanFrame* pop_tarjan_frame(TarjanFrame** work_stack) {
    #####:  187:    if (!*work_stack) return NULL;
    #####:  188:    TarjanFrame* frame = *work_stack;
    #####:  189:    *work_stack = frame->next;
    #####:  190:    return frame;
        -:  191:}
        -:  192:
    #####:  193:void tarjan_dfs(SCCRegistry* reg, Obj* v, SCC** result) {
    #####:  194:    if (!v) return;
        -:  195:
    #####:  196:    TarjanFrame* work_stack = NULL;
    #####:  197:    push_tarjan_frame(&work_stack, v, TARJAN_INIT);
        -:  198:
    #####:  199:    while (work_stack) {
    #####:  200:        TarjanFrame* frame = work_stack;
    #####:  201:        Obj* curr = frame->v;
        -:  202:
    #####:  203:        switch (frame->state) {
    #####:  204:        case TARJAN_INIT: {
    #####:  205:            SCCNode* node = get_or_create_node(reg, curr);
        -:  206:
        -:  207:            // Skip if already processed
    #####:  208:            if (node->id >= 0) {
    #####:  209:                free(pop_tarjan_frame(&work_stack));
    #####:  210:                break;
        -:  211:            }
        -:  212:
    #####:  213:            node->id = node->lowlink = reg->index++;
    #####:  214:            push_stack(reg, node);
    #####:  215:            frame->node = node;
        -:  216:
        -:  217:            // Process child 'a' first
    #####:  218:            frame->state = TARJAN_AFTER_A;
    #####:  219:            if (curr->is_pair && curr->a) {
    #####:  220:                SCCNode* w_node = get_node(reg, curr->a);
    #####:  221:                if (!w_node || w_node->id < 0) {
        -:  222:                    // Child not yet visited - push frame to process it
    #####:  223:                    frame->pushed_a = 1;
    #####:  224:                    push_tarjan_frame(&work_stack, curr->a, TARJAN_INIT);
    #####:  225:                } else if (w_node->on_stack) {
        -:  226:                    // Child is on stack - update lowlink with its id
    #####:  227:                    node->lowlink = min(node->lowlink, w_node->id);
        -:  228:                }
        -:  229:                // else: child already processed and not on stack - ignore
        -:  230:            }
    #####:  231:            break;
        -:  232:        }
        -:  233:
    #####:  234:        case TARJAN_AFTER_A: {
    #####:  235:            SCCNode* node = frame->node;
        -:  236:
        -:  237:            // Update lowlink after processing 'a' (only if we pushed a frame)
    #####:  238:            if (frame->pushed_a && curr->is_pair && curr->a) {
    #####:  239:                SCCNode* w_node = get_node(reg, curr->a);
    #####:  240:                if (w_node) {
    #####:  241:                    node->lowlink = min(node->lowlink, w_node->lowlink);
        -:  242:                }
        -:  243:            }
        -:  244:
        -:  245:            // Process child 'b'
    #####:  246:            frame->state = TARJAN_AFTER_B;
    #####:  247:            if (curr->is_pair && curr->b) {
    #####:  248:                SCCNode* w_node = get_node(reg, curr->b);
    #####:  249:                if (!w_node || w_node->id < 0) {
        -:  250:                    // Child not yet visited - push frame to process it
    #####:  251:                    frame->pushed_b = 1;
    #####:  252:                    push_tarjan_frame(&work_stack, curr->b, TARJAN_INIT);
    #####:  253:                } else if (w_node->on_stack) {
        -:  254:                    // Child is on stack - update lowlink with its id
    #####:  255:                    node->lowlink = min(node->lowlink, w_node->id);
        -:  256:                }
        -:  257:                // else: child already processed and not on stack - ignore
        -:  258:            }
    #####:  259:            break;
        -:  260:        }
        -:  261:
    #####:  262:        case TARJAN_AFTER_B: {
    #####:  263:            SCCNode* node = frame->node;
        -:  264:
        -:  265:            // Update lowlink after processing 'b' (only if we pushed a frame)
    #####:  266:            if (frame->pushed_b && curr->is_pair && curr->b) {
    #####:  267:                SCCNode* w_node = get_node(reg, curr->b);
    #####:  268:                if (w_node) {
    #####:  269:                    node->lowlink = min(node->lowlink, w_node->lowlink);
        -:  270:                }
        -:  271:            }
        -:  272:
        -:  273:            // If v is root of SCC
    #####:  274:            if (node->lowlink == node->id) {
    #####:  275:                SCC* scc = create_scc(reg);
        -:  276:                SCCNode* w;
        -:  277:                do {
    #####:  278:                    w = pop_stack(reg);
    #####:  279:                    if (w) {
    #####:  280:                        add_to_scc(scc, w->obj);
        -:  281:                    }
    #####:  282:                } while (w && w != node);
        -:  283:
    #####:  284:                scc->next = *result;
    #####:  285:                *result = scc;
        -:  286:            }
        -:  287:
    #####:  288:            free(pop_tarjan_frame(&work_stack));
    #####:  289:            break;
        -:  290:        }
        -:  291:
    #####:  292:        case TARJAN_DONE:
    #####:  293:            free(pop_tarjan_frame(&work_stack));
    #####:  294:            break;
        -:  295:        }
        -:  296:    }
        -:  297:}
        -:  298:
    #####:  299:SCC* compute_sccs(SCCRegistry* reg, Obj* root) {
    #####:  300:    reset_tarjan_state(reg);
    #####:  301:    SCC* result = NULL;
    #####:  302:    tarjan_dfs(reg, root, &result);
    #####:  303:    return result;
        -:  304:}
        -:  305:
        -:  306:// -- Freeze Operations --
        -:  307:
    #####:  308:void inc_scc_ref(SCC* scc) {
    #####:  309:    if (scc) scc->ref_count++;
    #####:  310:}
        -:  311:
    #####:  312:void release_scc(SCC* scc) {
    #####:  313:    if (!scc) return;
    #####:  314:    scc->ref_count--;
        -:  315:
    #####:  316:    if (scc->ref_count == 0) {
        -:  317:        // Free all members
    #####:  318:        for (int i = 0; i < scc->member_count; i++) {
    #####:  319:            free(scc->members[i]);
        -:  320:        }
    #####:  321:        free(scc->members);
    #####:  322:        scc->members = NULL;
    #####:  323:        scc->member_count = 0;
        -:  324:        // Note: SCC struct itself stays in registry until registry freed
        -:  325:    }
        -:  326:}
        -:  327:
        -:  328:// -- Freeze Point Detection --
        -:  329:
        -:  330:// Check if variable has no mutations after this point
    #####:  331:static int has_no_mutations(const char* var, Value* expr) {
    #####:  332:    if (!expr || is_nil(expr)) return 1;
        -:  333:
    #####:  334:    if (expr->tag == T_CELL) {
    #####:  335:        Value* op = car(expr);
    #####:  336:        Value* args = cdr(expr);
        -:  337:
        -:  338:        // Check for set! on this variable
    #####:  339:        if (op->tag == T_SYM && strcmp(op->s, "set!") == 0) {
    #####:  340:            Value* target = car(args);
    #####:  341:            if (target->tag == T_SYM && strcmp(target->s, var) == 0) {
    #####:  342:                return 0;  // Found mutation
        -:  343:            }
        -:  344:        }
        -:  345:
        -:  346:        // Check all subexpressions
    #####:  347:        if (!has_no_mutations(var, op)) return 0;
    #####:  348:        while (!is_nil(args)) {
    #####:  349:            if (!has_no_mutations(var, car(args))) return 0;
    #####:  350:            args = cdr(args);
        -:  351:        }
        -:  352:    }
        -:  353:
    #####:  354:    return 1;
        -:  355:}
        -:  356:
    #####:  357:int is_frozen_after_construction(const char* var, Value* body) {
        -:  358:    // A variable is "frozen" if there are no set! operations on it
        -:  359:    // after it's constructed
    #####:  360:    return has_no_mutations(var, body);
        -:  361:}
        -:  362:
    #####:  363:FreezePoint* detect_freeze_points(Value* expr) {
        -:  364:    // TODO: Implement more sophisticated freeze point detection
        -:  365:    // For now, we detect explicit (freeze x) forms
    #####:  366:    return NULL;
        -:  367:}
        -:  368:
        -:  369:// -- Code Generation --
        -:  370:
       98:  371:void gen_scc_runtime(void) {
       98:  372:    printf("\n// Phase 6b: SCC-based RC Runtime (ISMM 2024)\n");
       98:  373:    printf("// Reference Counting Deeply Immutable Data Structures with Cycles\n\n");
        -:  374:
       98:  375:    printf("typedef struct SCC {\n");
       98:  376:    printf("    int id;\n");
       98:  377:    printf("    Obj** members;\n");
       98:  378:    printf("    int member_count;\n");
       98:  379:    printf("    int capacity;\n");
       98:  380:    printf("    int ref_count;\n");
       98:  381:    printf("    struct SCC* next;\n");
       98:  382:    printf("} SCC;\n\n");
        -:  383:
       98:  384:    printf("static int SCC_NEXT_ID = 0;\n\n");
        -:  385:
       98:  386:    printf("// Tarjan's algorithm for SCC computation\n");
       98:  387:    printf("typedef struct TarjanNode {\n");
       98:  388:    printf("    Obj* obj;\n");
       98:  389:    printf("    int index;\n");
       98:  390:    printf("    int lowlink;\n");
       98:  391:    printf("    int on_stack;\n");
       98:  392:    printf("    struct TarjanNode* next;      // For linked list cleanup\n");
       98:  393:    printf("    struct TarjanNode* hash_next; // For hash bucket chain\n");
       98:  394:    printf("} TarjanNode;\n\n");
        -:  395:
       98:  396:    printf("typedef struct TarjanStack {\n");
       98:  397:    printf("    Obj* obj;\n");
       98:  398:    printf("    struct TarjanStack* next;\n");
       98:  399:    printf("} TarjanStack;\n\n");
        -:  400:
       98:  401:    printf("#define TARJAN_HASH_SIZE 1024\n");
       98:  402:    printf("TarjanNode* TARJAN_HASH[TARJAN_HASH_SIZE];\n");
       98:  403:    printf("TarjanNode* TARJAN_NODES = NULL;\n");
       98:  404:    printf("TarjanStack* TARJAN_STACK = NULL;\n");
       98:  405:    printf("int TARJAN_INDEX = 0;\n\n");
        -:  406:
       98:  407:    printf("static size_t tarjan_hash_ptr(void* p) {\n");
       98:  408:    printf("    size_t x = (size_t)p;\n");
       98:  409:    printf("    x = ((x >> 16) ^ x) * 0x45d9f3b;\n");
       98:  410:    printf("    x = ((x >> 16) ^ x) * 0x45d9f3b;\n");
       98:  411:    printf("    return (x >> 16) ^ x;\n");
       98:  412:    printf("}\n\n");
        -:  413:
       98:  414:    printf("TarjanNode* get_tarjan_node(Obj* obj) {\n");
       98:  415:    printf("    size_t idx = tarjan_hash_ptr(obj) %% TARJAN_HASH_SIZE;\n");
       98:  416:    printf("    TarjanNode* n = TARJAN_HASH[idx];\n");
       98:  417:    printf("    while (n) {\n");
       98:  418:    printf("        if (n->obj == obj) return n;\n");
       98:  419:    printf("        n = n->hash_next;\n");
       98:  420:    printf("    }\n");
       98:  421:    printf("    // Create new node\n");
       98:  422:    printf("    n = malloc(sizeof(TarjanNode));\n");
       98:  423:    printf("    if (!n) return NULL;\n");
       98:  424:    printf("    n->obj = obj;\n");
       98:  425:    printf("    n->index = -1;\n");
       98:  426:    printf("    n->lowlink = -1;\n");
       98:  427:    printf("    n->on_stack = 0;\n");
       98:  428:    printf("    n->next = TARJAN_NODES;\n");
       98:  429:    printf("    n->hash_next = TARJAN_HASH[idx];\n");
       98:  430:    printf("    TARJAN_NODES = n;\n");
       98:  431:    printf("    TARJAN_HASH[idx] = n;\n");
       98:  432:    printf("    return n;\n");
       98:  433:    printf("}\n\n");
        -:  434:
       98:  435:    printf("void tarjan_stack_push(Obj* obj) {\n");
       98:  436:    printf("    TarjanStack* s = malloc(sizeof(TarjanStack));\n");
       98:  437:    printf("    s->obj = obj;\n");
       98:  438:    printf("    s->next = TARJAN_STACK;\n");
       98:  439:    printf("    TARJAN_STACK = s;\n");
       98:  440:    printf("}\n\n");
        -:  441:
       98:  442:    printf("Obj* tarjan_stack_pop(void) {\n");
       98:  443:    printf("    if (!TARJAN_STACK) return NULL;\n");
       98:  444:    printf("    TarjanStack* s = TARJAN_STACK;\n");
       98:  445:    printf("    Obj* obj = s->obj;\n");
       98:  446:    printf("    TARJAN_STACK = s->next;\n");
       98:  447:    printf("    free(s);\n");
       98:  448:    printf("    return obj;\n");
       98:  449:    printf("}\n\n");
        -:  450:
       98:  451:    printf("void reset_tarjan_state(void) {\n");
       98:  452:    printf("    TarjanNode* n = TARJAN_NODES;\n");
       98:  453:    printf("    while (n) {\n");
       98:  454:    printf("        TarjanNode* next = n->next;\n");
       98:  455:    printf("        free(n);\n");
       98:  456:    printf("        n = next;\n");
       98:  457:    printf("    }\n");
       98:  458:    printf("    TARJAN_NODES = NULL;\n");
       98:  459:    printf("    // Clear hash table\n");
       98:  460:    printf("    for (int i = 0; i < TARJAN_HASH_SIZE; i++) TARJAN_HASH[i] = NULL;\n");
       98:  461:    printf("    while (TARJAN_STACK) {\n");
       98:  462:    printf("        TarjanStack* s = TARJAN_STACK;\n");
       98:  463:    printf("        TARJAN_STACK = s->next;\n");
       98:  464:    printf("        free(s);\n");
       98:  465:    printf("    }\n");
       98:  466:    printf("    TARJAN_INDEX = 0;\n");
       98:  467:    printf("}\n\n");
        -:  468:
        -:  469:    // Generate iterative tarjan_strongconnect implementation
       98:  470:    printf("typedef enum { TARJAN_INIT, TARJAN_AFTER_A, TARJAN_AFTER_B, TARJAN_DONE } TarjanState;\n\n");
        -:  471:    
       98:  472:    printf("typedef struct TarjanWorkFrame {\n");
       98:  473:    printf("    Obj* v;\n");
       98:  474:    printf("    TarjanNode* node;\n");
       98:  475:    printf("    TarjanState state;\n");
       98:  476:    printf("    int pushed_a;\n");
       98:  477:    printf("    int pushed_b;\n");
       98:  478:    printf("    struct TarjanWorkFrame* next;\n");
       98:  479:    printf("} TarjanWorkFrame;\n\n");
        -:  480:
       98:  481:    printf("static int push_work_frame(TarjanWorkFrame** stack, Obj* v, TarjanState state) {\n");
       98:  482:    printf("    TarjanWorkFrame* f = malloc(sizeof(TarjanWorkFrame));\n");
       98:  483:    printf("    if (!f) return 0;\n");
       98:  484:    printf("    f->v = v;\n");
       98:  485:    printf("    f->node = NULL;\n");
       98:  486:    printf("    f->state = state;\n");
       98:  487:    printf("    f->pushed_a = 0;\n");
       98:  488:    printf("    f->pushed_b = 0;\n");
       98:  489:    printf("    f->next = *stack;\n");
       98:  490:    printf("    *stack = f;\n");
       98:  491:    printf("    return 1;\n");
       98:  492:    printf("}\n\n");
        -:  493:
       98:  494:    printf("static TarjanWorkFrame* pop_work_frame(TarjanWorkFrame** stack) {\n");
       98:  495:    printf("    if (!*stack) return NULL;\n");
       98:  496:    printf("    TarjanWorkFrame* f = *stack;\n");
       98:  497:    printf("    *stack = f->next;\n");
       98:  498:    printf("    return f;\n");
       98:  499:    printf("}\n\n");
        -:  500:
       98:  501:    printf("void tarjan_strongconnect(Obj* root_obj, SCC** result) {\n");
       98:  502:    printf("    if (!root_obj) return;\n");
       98:  503:    printf("    TarjanWorkFrame* work_stack = NULL;\n");
       98:  504:    printf("    push_work_frame(&work_stack, root_obj, TARJAN_INIT);\n\n");
        -:  505:
       98:  506:    printf("    while (work_stack) {\n");
       98:  507:    printf("        TarjanWorkFrame* frame = work_stack;\n");
       98:  508:    printf("        Obj* v = frame->v;\n\n");
        -:  509:
       98:  510:    printf("        switch (frame->state) {\n");
       98:  511:    printf("        case TARJAN_INIT: {\n");
       98:  512:    printf("            TarjanNode* node = get_tarjan_node(v);\n");
       98:  513:    printf("            if (node->index >= 0) {\n");
       98:  514:    printf("                free(pop_work_frame(&work_stack));\n");
       98:  515:    printf("                break;\n");
       98:  516:    printf("            }\n");
       98:  517:    printf("            node->index = TARJAN_INDEX;\n");
       98:  518:    printf("            node->lowlink = TARJAN_INDEX;\n");
       98:  519:    printf("            TARJAN_INDEX++;\n");
       98:  520:    printf("            tarjan_stack_push(v);\n");
       98:  521:    printf("            node->on_stack = 1;\n");
       98:  522:    printf("            frame->node = node;\n");
       98:  523:    printf("            frame->state = TARJAN_AFTER_A;\n\n");
        -:  524:
       98:  525:    printf("            if (v->is_pair && v->a) {\n");
       98:  526:    printf("                TarjanNode* w = get_tarjan_node(v->a);\n");
       98:  527:    printf("                if (w->index < 0) {\n");
       98:  528:    printf("                    frame->pushed_a = 1;\n");
       98:  529:    printf("                    push_work_frame(&work_stack, v->a, TARJAN_INIT);\n");
       98:  530:    printf("                } else if (w->on_stack) {\n");
       98:  531:    printf("                    if (node->lowlink > w->index) node->lowlink = w->index;\n");
       98:  532:    printf("                }\n");
       98:  533:    printf("            }\n");
       98:  534:    printf("            break;\n");
       98:  535:    printf("        }\n\n");
        -:  536:
       98:  537:    printf("        case TARJAN_AFTER_A: {\n");
       98:  538:    printf("            TarjanNode* node = frame->node;\n");
       98:  539:    printf("            if (frame->pushed_a && v->is_pair && v->a) {\n");
       98:  540:    printf("                TarjanNode* w = get_tarjan_node(v->a);\n");
       98:  541:    printf("                if (node->lowlink > w->lowlink) node->lowlink = w->lowlink;\n");
       98:  542:    printf("            }\n");
       98:  543:    printf("            frame->state = TARJAN_AFTER_B;\n\n");
        -:  544:
       98:  545:    printf("            if (v->is_pair && v->b) {\n");
       98:  546:    printf("                TarjanNode* w = get_tarjan_node(v->b);\n");
       98:  547:    printf("                if (w->index < 0) {\n");
       98:  548:    printf("                    frame->pushed_b = 1;\n");
       98:  549:    printf("                    push_work_frame(&work_stack, v->b, TARJAN_INIT);\n");
       98:  550:    printf("                } else if (w->on_stack) {\n");
       98:  551:    printf("                    if (node->lowlink > w->index) node->lowlink = w->index;\n");
       98:  552:    printf("                }\n");
       98:  553:    printf("            }\n");
       98:  554:    printf("            break;\n");
       98:  555:    printf("        }\n\n");
        -:  556:
       98:  557:    printf("        case TARJAN_AFTER_B: {\n");
       98:  558:    printf("            TarjanNode* node = frame->node;\n");
       98:  559:    printf("            if (frame->pushed_b && v->is_pair && v->b) {\n");
       98:  560:    printf("                TarjanNode* w = get_tarjan_node(v->b);\n");
       98:  561:    printf("                if (node->lowlink > w->lowlink) node->lowlink = w->lowlink;\n");
       98:  562:    printf("            }\n\n");
        -:  563:
       98:  564:    printf("            if (node->lowlink == node->index) {\n");
       98:  565:    printf("                SCC* scc = malloc(sizeof(SCC));\n");
       98:  566:    printf("                scc->id = SCC_NEXT_ID++;\n");
       98:  567:    printf("                scc->members = malloc(16 * sizeof(Obj*));\n");
       98:  568:    printf("                scc->member_count = 0;\n");
       98:  569:    printf("                scc->capacity = 16;\n");
       98:  570:    printf("                scc->ref_count = 1;\n");
       98:  571:    printf("                scc->next = *result;\n");
       98:  572:    printf("                *result = scc;\n\n");
        -:  573:
       98:  574:    printf("                Obj* w;\n");
       98:  575:    printf("                do {\n");
       98:  576:    printf("                    w = tarjan_stack_pop();\n");
       98:  577:    printf("                    TarjanNode* w_node = get_tarjan_node(w);\n");
       98:  578:    printf("                    w_node->on_stack = 0;\n");
       98:  579:    printf("                    w->scc_id = scc->id;\n");
       98:  580:    printf("                    if (scc->member_count >= scc->capacity) {\n");
       98:  581:    printf("                        scc->capacity *= 2;\n");
       98:  582:    printf("                        scc->members = realloc(scc->members, scc->capacity * sizeof(Obj*));\n");
       98:  583:    printf("                    }\n");
       98:  584:    printf("                    scc->members[scc->member_count++] = w;\n");
       98:  585:    printf("                } while (w != v);\n");
       98:  586:    printf("            }\n");
       98:  587:    printf("            free(pop_work_frame(&work_stack));\n");
       98:  588:    printf("            break;\n");
       98:  589:    printf("        }\n\n");
        -:  590:    
       98:  591:    printf("        case TARJAN_DONE:\n");
       98:  592:    printf("            free(pop_work_frame(&work_stack));\n");
       98:  593:    printf("            break;\n");
       98:  594:    printf("        }\n");
       98:  595:    printf("    }\n");
       98:  596:    printf("}\n\n");
        -:  597:
       98:  598:    printf("SCC* freeze_cyclic(Obj* root) {\n");
       98:  599:    printf("    // Reset Tarjan state\n");
       98:  600:    printf("    reset_tarjan_state();\n");
       98:  601:    printf("    \n");
       98:  602:    printf("    SCC* sccs = NULL;\n");
       98:  603:    printf("    tarjan_strongconnect(root, &sccs);\n");
       98:  604:    printf("    return sccs;\n");
       98:  605:    printf("}\n\n");
        -:  606:
       98:  607:    printf("void release_scc(SCC* scc) {\n");
       98:  608:    printf("    if (!scc) return;\n");
       98:  609:    printf("    scc->ref_count--;\n");
       98:  610:    printf("    if (scc->ref_count == 0) {\n");
       98:  611:    printf("        for (int i = 0; i < scc->member_count; i++) {\n");
       98:  612:    printf("            free(scc->members[i]);\n");
       98:  613:    printf("        }\n");
       98:  614:    printf("        free(scc->members);\n");
       98:  615:    printf("        free(scc);\n");
       98:  616:    printf("    }\n");
       98:  617:    printf("}\n\n");
        -:  618:
       98:  619:    printf("void inc_scc_ref(SCC* scc) {\n");
       98:  620:    printf("    if (scc) scc->ref_count++;\n");
       98:  621:    printf("}\n\n");
       98:  622:}
        -:  623:
    #####:  624:void gen_freeze_call(const char* var) {
    #####:  625:    printf("    SCC* %s_scc = freeze_cyclic(%s);\n", var, var);
    #####:  626:}
        -:  627:
    #####:  628:void gen_release_scc_call(const char* var) {
    #####:  629:    printf("    release_scc(%s_scc);\n", var);
    #####:  630:}
